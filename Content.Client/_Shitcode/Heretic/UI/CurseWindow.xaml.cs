using System.Numerics;
using Content.Client.Lathe.UI;
using Content.Client.UserInterface.Controls;
using Content.Shared._Shitcode.Heretic.Curses;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;

namespace Content.Client._Shitcode.Heretic.UI;

[GenerateTypedNameReferences]
public sealed partial class CurseWindow : FancyWindow
{
    [Dependency] private readonly IGameTiming _timing = default!;
    [Dependency] private readonly IPrototypeManager _proto = default!;

    private Dictionary<EntProtoId, CurseProviderData> _providerData = new();
    private HashSet<CurseData> _data = new();
    private readonly Dictionary<Button, CurseData> _buttons = new();
    private readonly Dictionary<int, EntProtoId> _ids = new();
    private string _searchText = string.Empty;

    public event Action<NetEntity, EntProtoId>? ButtonClicked;

    public CurseWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        CursesButton.OnItemSelected += id => CursesButton.SelectId(id.Id);
        SearchBar.OnTextChanged += OnSearchTextChanged;
    }

    public void UpdateData(HashSet<CurseData> data, Dictionary<EntProtoId, CurseProviderData> providerData)
    {
        _data = data;
        if (_providerData.Count == 0 || CursesButton.ItemCount == 0)
        {
            _providerData = providerData;
            UpdateCursesButton();
        }

        Populate();
    }

    public void UpdateCursesButton()
    {
        _ids.Clear();
        CursesButton.Clear();
        var i = 0;
        foreach (var proto in _providerData.Keys)
        {
            CursesButton.AddItem(_proto.Index(proto).Name, i);
            _ids[i] = proto;
            i++;
        }

        CursesButton.SelectId(0);
    }

    public void Populate()
    {
        _buttons.Clear();
        ButtonContainer.DisposeAllChildren();

        foreach (var item in _data)
        {
            var canCurse = item.Multiplier != 0f && item.NextCurseTime < _timing.RealTime;
            var itemName = item.Name;
            var itemDesc = canCurse
                ? Loc.GetString("heretic-curse-window-can-curse")
                : Loc.GetString("heretic-curse-window-cant-curse");

            var button = new Button
            {
                Text = itemName,
                Disabled = !canCurse,
            };

            _buttons[button] = item;

            if (!string.IsNullOrEmpty(itemDesc))
                button.TooltipSupplier = _ => new RecipeTooltip(itemDesc);

            button.OnButtonUp += _ => ButtonClicked?.Invoke(item.Entity, _ids[CursesButton.SelectedId]);
            button.Visible = ButtonIsVisible(button);

            ButtonContainer.AddChild(button);
        }
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        foreach (var obj in ButtonContainer.Children)
        {
            if (obj is not Button button || !_buttons.TryGetValue(button, out var data))
                continue;

            if (!button.Disabled)
            {
                var proto = _ids[CursesButton.SelectedId];
                var providerData = _providerData[proto];
                DisplayTime(button, data.Name, providerData.Time * data.Multiplier);
                continue;
            }

            if (data.Multiplier == 0f)
                continue;

            var time = data.NextCurseTime - _timing.CurTime;
            if (time > TimeSpan.Zero)
                DisplayTime(button, data.Name, time);
            else
                button.Disabled = false;
        }
    }

    private void DisplayTime(Button button, string baseText, TimeSpan time)
    {
        var timeStr = time.ToString(@"mm\:ss");
        button.Text = $"{baseText} ({timeStr})";
    }

    private bool ButtonIsVisible(Button button)
    {
        return string.IsNullOrEmpty(_searchText) || button.Text == null ||
               button.Text.Contains(_searchText, StringComparison.OrdinalIgnoreCase);
    }

    private void UpdateVisibleButtons()
    {
        foreach (var child in ButtonContainer.Children)
        {
            if (child is Button button)
                button.Visible = ButtonIsVisible(button);
        }
    }

    private void OnSearchTextChanged(LineEdit.LineEditEventArgs args)
    {
        _searchText = args.Text;

        UpdateVisibleButtons();
        // Reset scroll bar so they can see the relevant results.
        Scroll.SetScrollValue(Vector2.Zero);
    }
}
