// SPDX-FileCopyrightText: 2021 Swept <sweptwastaken@protonmail.com>
// SPDX-FileCopyrightText: 2022 Paul Ritter <ritter.paul1@googlemail.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 James Simonson <jamessimo89@gmail.com>
// SPDX-FileCopyrightText: 2023 Kevin Zheng <kevinz5000@gmail.com>
// SPDX-FileCopyrightText: 2023 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2024 Tadeo <td12233a@gmail.com>
// SPDX-FileCopyrightText: 2024 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Dreykor <160512778+Dreykor@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 GabyChangelog <agentepanela2@gmail.com>
// SPDX-FileCopyrightText: 2025 Kyoth25f <kyoth25f@gmail.com>
// SPDX-FileCopyrightText: 2025 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2025 SX-7 <sn1.test.preria.2002@gmail.com>
// SPDX-FileCopyrightText: 2025 Steve <marlumpy@gmail.com>
// SPDX-FileCopyrightText: 2025 Tay <td12233a@gmail.com>
// SPDX-FileCopyrightText: 2025 Tyranex <bobthezombie4@gmail.com>
// SPDX-FileCopyrightText: 2025 funkystationbot <funky@funkystation.org>
// SPDX-FileCopyrightText: 2025 marc-pelletier <113944176+marc-pelletier@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 taydeo <td12233a@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Client.Stylesheets;
using Content.Shared.APC;
using Robust.Client.Graphics;
using FancyWindow = Content.Client.UserInterface.Controls.FancyWindow;

namespace Content.Client.Power.APC.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class ApcMenu : FancyWindow
    {
        public event Action? OnBreaker;
        public event Action? OnSiphon; // Funkystation -> Malf AI

        public ApcMenu()
        {
            IoCManager.InjectDependencies(this);
            RobustXamlLoader.Load(this);

            BreakerButton.OnPressed += _ => OnBreaker?.Invoke();
            SiphonButton.OnPressed += _ => OnSiphon?.Invoke(); // Funkystation -> Malf AI
        }

        public void SetEntity(EntityUid entity)
        {
            EntityView.SetEntity(entity);
        }

        public void UpdateState(BoundUserInterfaceState state)
        {
            var castState = (ApcBoundInterfaceState) state;

            if (!BreakerButton.Disabled)
            {
                BreakerButton.Pressed = castState.MainBreaker;
            }

            if (PowerLabel != null)
            {
                PowerLabel.Text = castState.Power + " W";
            }

            if (ExternalPowerStateLabel != null)
            {
                switch (castState.ApcExternalPower)
                {
                    case ApcExternalPowerState.None:
                        ExternalPowerStateLabel.Text = Loc.GetString("apc-menu-power-state-none");
                        ExternalPowerStateLabel.SetOnlyStyleClass(StyleNano.StyleClassPowerStateNone);
                        break;
                    case ApcExternalPowerState.Low:
                        ExternalPowerStateLabel.Text = Loc.GetString("apc-menu-power-state-low");
                        ExternalPowerStateLabel.SetOnlyStyleClass(StyleNano.StyleClassPowerStateLow);
                        break;
                    case ApcExternalPowerState.Good:
                        ExternalPowerStateLabel.Text = Loc.GetString("apc-menu-power-state-good");
                        ExternalPowerStateLabel.SetOnlyStyleClass(StyleNano.StyleClassPowerStateGood);
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            if (ChargeBar != null)
            {
                ChargeBar.Value = castState.Charge;
                UpdateChargeBarColor(castState.Charge);
                var chargePercentage = (castState.Charge / ChargeBar.MaxValue);
                ChargePercentage.Text = Loc.GetString("apc-menu-charge-label",("percent",  chargePercentage.ToString("P0")));
            }

            // Funkystation -> Malf AI
            // Disable the siphon button if this APC has already been siphoned.
            if (SiphonButton != null)
            {
                SiphonButton.Disabled = castState.Siphoned;
                SiphonButton.ToolTip = castState.Siphoned
                    ? Loc.GetString("apc-menu-siphon-already")
                    : null;
            }
        }

        public void SetAccessEnabled(bool hasAccess)
        {
            if(hasAccess)
            {
                BreakerButton.Disabled = false;
                BreakerButton.ToolTip = null;
            }
            else
            {
                BreakerButton.Disabled = true;
                BreakerButton.ToolTip = Loc.GetString("apc-component-insufficient-access");
            }
        }

        // Funkystation -> Malf AI
        public void SetSiphonVisible(bool visible)
        {
            if (SiphonSpacer is not null)
                SiphonSpacer.Visible = visible;
            if (SiphonContainer is not null)
                SiphonContainer.Visible = visible;
            if (SiphonButton is not null)
                SiphonButton.Visible = visible;
        }

        private void UpdateChargeBarColor(float charge)
        {
            if (ChargeBar == null)
            {
                return;
            }

            var normalizedCharge = charge / ChargeBar.MaxValue;

            const float leftHue = 0.0f; // Red
            const float middleHue = 0.066f; // Orange
            const float rightHue = 0.33f; // Green
            const float saturation = 1.0f; // Uniform saturation
            const float value = 0.8f; // Uniform value / brightness
            const float alpha = 1.0f; // Uniform alpha

            // These should add up to 1.0 or your transition won't be smooth
            const float leftSideSize = 0.5f; // Fraction of ChargeBar lerped from leftHue to middleHue
            const float rightSideSize = 0.5f; // Fraction of ChargeBar lerped from middleHue to rightHue

            float finalHue;
            if (normalizedCharge <= leftSideSize)
            {
                normalizedCharge /= leftSideSize; // Adjust range to 0.0 to 1.0
                finalHue = MathHelper.Lerp(leftHue, middleHue, normalizedCharge);
            }
            else
            {
                normalizedCharge = (normalizedCharge - leftSideSize) / rightSideSize; // Adjust range to 0.0 to 1.0.
                finalHue = MathHelper.Lerp(middleHue, rightHue, normalizedCharge);
            }

            // Check if null first to avoid repeatedly creating this.
            ChargeBar.ForegroundStyleBoxOverride ??= new StyleBoxFlat();

            var foregroundStyleBoxOverride = (StyleBoxFlat) ChargeBar.ForegroundStyleBoxOverride;
            foregroundStyleBoxOverride.BackgroundColor =
                Color.FromHsv(new Vector4(finalHue, saturation, value, alpha));
        }
    }
}