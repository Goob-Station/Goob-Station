// SPDX-FileCopyrightText: 2021 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 2022 Justin Trotter <trotter.justin@gmail.com>
// SPDX-FileCopyrightText: 2022 Paul Ritter <ritter.paul1@googlemail.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 20kdc <asdd2808@gmail.com>
// SPDX-FileCopyrightText: 2023 Ahion <58528255+Ahion@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Alex <129697969+Lomcastar@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DEATHB4DEFEAT <77995199+DEATHB4DEFEAT@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Julian Giebel <juliangiebel@live.de>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 chromiumboy <50505512+chromiumboy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 eoineoineoin <eoin.mcloughlin+gh@gmail.com>
// SPDX-FileCopyrightText: 2023 keronshb <54602815+keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2024 Alzore <140123969+Blackern5000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Brandon Hu <103440971+Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 CaasGit <87243814+CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 EmoGarbage404 <retron404@gmail.com>
// SPDX-FileCopyrightText: 2024 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Hrosts <35345601+Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 2024 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JustCone <141039037+JustCone14@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Killerqu00 <47712032+Killerqu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ko4ergaPunk <62609550+Ko4ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kukutis96513 <146854220+Kukutis96513@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Lye <128915833+Lyroth001@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MerrytheManokit <167581110+MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MureixloI <132683811+MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 NakataRin <45946146+NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 OrangeMoronage9622 <whyteterry0092@gmail.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Preston Smith <92108534+thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Pspritechologist <81725545+Pspritechologist@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Psychpsyo <60073468+Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Repo <47093363+Titian3@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 RiceMar1244 <138547931+RiceMar1244@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Simon <63975668+Simyon264@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Stalen <33173619+stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TakoDragon <69509841+BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Unkn0wn_Gh0st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 Vigers Ray <60344369+VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deathride58 <deathride58@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 dffdff2423 <dffdff2423@gmail.com>
// SPDX-FileCopyrightText: 2024 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 2024 foboscheshir <156405958+foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 nikthechampiongr <32041239+nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 saintmuntzer <47153094+saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 shamp <140359015+shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 strO0pwafel <153459934+strO0pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 2024 themias <89101928+themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 to4no_fix <156101927+chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 voidnull000 <18663194+voidnull000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 eoineoineoin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2025 pathetic meowmeow <uhhadd@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Numerics;
using Content.Client.Pinpointer.UI;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Shared.Medical.SuitSensor;
using Content.Shared.StatusIcon;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Map;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Client.Medical.CrewMonitoring;

[GenerateTypedNameReferences]
public sealed partial class CrewMonitoringWindow : FancyWindow
{
    [Dependency] private readonly IEntityManager _entManager = default!;
    [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
    private readonly SharedTransformSystem _transformSystem;
    private readonly SpriteSystem _spriteSystem;

    private NetEntity? _trackedEntity;
    private bool _tryToScrollToListFocus;
    private Texture? _blipTexture;

    public CrewMonitoringWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _transformSystem = _entManager.System<SharedTransformSystem>();
        _spriteSystem = _entManager.System<SpriteSystem>();

        NavMap.TrackedEntitySelectedAction += SetTrackedEntityFromNavMap;
    }

    public void Set(string stationName, EntityUid? mapUid)
    {
        _blipTexture = _spriteSystem.Frame0(new SpriteSpecifier.Texture(new ResPath("/Textures/Interface/NavMap/beveled_circle.png")));

        if (_entManager.TryGetComponent<TransformComponent>(mapUid, out var xform))
            NavMap.MapUid = xform.GridUid;

        else
            NavMap.Visible = false;

        StationName.AddStyleClass("LabelBig");
        StationName.Text = stationName;
        NavMap.ForceNavMapUpdate();
    }

    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        if (_tryToScrollToListFocus)
            TryToScrollToFocus();
    }

    public void ShowSensors(List<SuitSensorStatus> sensors, EntityUid monitor, EntityCoordinates? monitorCoords)
    {
        ClearOutDatedData();

        // No server label
        if (sensors.Count == 0)
        {
            NoServerLabel.Visible = true;
            return;
        }

        NoServerLabel.Visible = false;

        // Order sensor data
        var orderedSensors = sensors.OrderBy(n => n.Name).OrderBy(j => j.Job);
        var assignedSensors = new HashSet<SuitSensorStatus>();
        var departments = sensors.SelectMany(d => d.JobDepartments).Distinct().OrderBy(n => n);

        // Create department labels and populate lists
        foreach (var department in departments)
        {
            var departmentSensors = orderedSensors.Where(d => d.JobDepartments.Contains(department));

            if (departmentSensors == null || !departmentSensors.Any())
                continue;

            foreach (var sensor in departmentSensors)
                assignedSensors.Add(sensor);

            if (SensorsTable.ChildCount > 0)
            {
                var spacer = new Control()
                {
                    SetHeight = 20,
                };

                SensorsTable.AddChild(spacer);
            }

            var deparmentLabel = new RichTextLabel()
            {
                Margin = new Thickness(10, 0),
                HorizontalExpand = true,
            };

            deparmentLabel.SetMessage(department);
            deparmentLabel.StyleClasses.Add(StyleNano.StyleClassTooltipActionDescription);

            SensorsTable.AddChild(deparmentLabel);

            PopulateDepartmentList(departmentSensors);
        }

        // Account for any non-station users
        var remainingSensors = orderedSensors.Except(assignedSensors);

        if (remainingSensors.Any())
        {
            var spacer = new Control()
            {
                SetHeight = 20,
            };

            SensorsTable.AddChild(spacer);

            var deparmentLabel = new RichTextLabel()
            {
                Margin = new Thickness(10, 0),
                HorizontalExpand = true,
            };

            deparmentLabel.SetMessage(Loc.GetString("crew-monitoring-user-interface-no-department"));
            deparmentLabel.StyleClasses.Add(StyleNano.StyleClassTooltipActionDescription);

            SensorsTable.AddChild(deparmentLabel);

            PopulateDepartmentList(remainingSensors);
        }

        // Show monitor on nav map
        if (monitorCoords != null && _blipTexture != null)
        {
            NavMap.TrackedEntities[_entManager.GetNetEntity(monitor)] = new NavMapBlip(monitorCoords.Value, _blipTexture, Color.Cyan, true, false);
        }
    }

    private void PopulateDepartmentList(IEnumerable<SuitSensorStatus> departmentSensors)
    {
        // Populate departments
        foreach (var sensor in departmentSensors)
        {
            if (!string.IsNullOrEmpty(SearchLineEdit.Text)
                && !sensor.Name.Contains(SearchLineEdit.Text, StringComparison.CurrentCultureIgnoreCase)
                && !sensor.Job.Contains(SearchLineEdit.Text, StringComparison.CurrentCultureIgnoreCase))
                continue;

            var coordinates = _entManager.GetCoordinates(sensor.Coordinates);

            // Add a button that will hold a username and other details
            NavMap.LocalizedNames.TryAdd(sensor.SuitSensorUid, sensor.Name + ", " + sensor.Job);

            var sensorButton = new CrewMonitoringButton()
            {
                SuitSensorUid = sensor.SuitSensorUid,
                Coordinates = coordinates,
                Disabled = (coordinates == null),
                HorizontalExpand = true,
            };

            if (sensor.SuitSensorUid == _trackedEntity)
                sensorButton.AddStyleClass(StyleNano.StyleClassButtonColorGreen);

            SensorsTable.AddChild(sensorButton);

            // Primary container to hold the button UI elements
            var mainContainer = new BoxContainer()
            {
                Orientation = LayoutOrientation.Horizontal,
                HorizontalExpand = true,
            };

            sensorButton.AddChild(mainContainer);

            // User status container
            var statusContainer = new BoxContainer()
            {
                SizeFlagsStretchRatio = 1.25f,
                Orientation = LayoutOrientation.Horizontal,
                HorizontalExpand = true,
            };

            mainContainer.AddChild(statusContainer);

            // Suit coords indicator
            var suitCoordsIndicator = new TextureRect()
            {
                Texture = _blipTexture,
                TextureScale = new Vector2(0.25f, 0.25f),
                Modulate = coordinates != null ? Color.LimeGreen : Color.DarkRed,
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Center,
            };

            statusContainer.AddChild(suitCoordsIndicator);

            // Specify texture for the user status icon
            var specifier = new SpriteSpecifier.Rsi(new ResPath("Interface/Alerts/human_crew_monitoring.rsi"), "alive");

            if (!sensor.IsAlive)
            {
                specifier = new SpriteSpecifier.Rsi(new ResPath("Interface/Alerts/human_crew_monitoring.rsi"), "dead");
            }

            else if (sensor.DamagePercentage != null)
            {
                var index = MathF.Round(4f * sensor.DamagePercentage.Value);

                if (index >= 5)
                    specifier = new SpriteSpecifier.Rsi(new ResPath("Interface/Alerts/human_crew_monitoring.rsi"), "critical");

                else
                    specifier = new SpriteSpecifier.Rsi(new ResPath("Interface/Alerts/human_crew_monitoring.rsi"), "health" + index);
            }

            // Status icon
            var statusIcon = new AnimatedTextureRect
            {
                HorizontalAlignment = HAlignment.Center,
                VerticalAlignment = VAlignment.Center,
                Margin = new Thickness(0, 1, 3, 0),
            };

            statusIcon.SetFromSpriteSpecifier(specifier);
            statusIcon.DisplayRect.TextureScale = new Vector2(2f, 2f);

            statusContainer.AddChild(statusIcon);

            // User name
            var nameLabel = new Label()
            {
                Text = sensor.Name,
                HorizontalExpand = true,
                ClipText = true,
            };

            statusContainer.AddChild(nameLabel);

            // User job container
            var jobContainer = new BoxContainer()
            {
                Orientation = LayoutOrientation.Horizontal,
                HorizontalExpand = true,
            };

            mainContainer.AddChild(jobContainer);

            // Job icon
            if (_prototypeManager.TryIndex<JobIconPrototype>(sensor.JobIcon, out var proto))
            {
                var jobIcon = new TextureRect()
                {
                    TextureScale = new Vector2(2f, 2f),
                    VerticalAlignment = VAlignment.Center,
                    Texture = _spriteSystem.Frame0(proto.Icon),
                    Margin = new Thickness(5, 0, 5, 0),
                };

                jobContainer.AddChild(jobIcon);
            }

            // Job name
            var jobLabel = new Label()
            {
                Text = sensor.Job,
                HorizontalExpand = true,
                ClipText = true,
            };

            jobContainer.AddChild(jobLabel);

            // Add user coordinates to the navmap
            if (coordinates != null && NavMap.Visible && _blipTexture != null)
            {
                NavMap.TrackedEntities.TryAdd(sensor.SuitSensorUid,
                    new NavMapBlip
                    (CoordinatesToLocal(coordinates.Value),
                    _blipTexture,
                    (_trackedEntity == null || sensor.SuitSensorUid == _trackedEntity) ? Color.LimeGreen : Color.LimeGreen * Color.DimGray,
                    sensor.SuitSensorUid == _trackedEntity));

                NavMap.Focus = _trackedEntity;

                // On button up
                sensorButton.OnButtonUp += args =>
                {
                    var prevTrackedEntity = _trackedEntity;

                    if (_trackedEntity == sensor.SuitSensorUid)
                    {
                        _trackedEntity = null;
                    }

                    else
                    {
                        _trackedEntity = sensor.SuitSensorUid;
                        NavMap.CenterToCoordinates(coordinates.Value);
                    }

                    NavMap.Focus = _trackedEntity;

                    UpdateSensorsTable(_trackedEntity, prevTrackedEntity);
                };
            }
        }
    }

    private void SetTrackedEntityFromNavMap(NetEntity? netEntity)
    {
        var prevTrackedEntity = _trackedEntity;
        _trackedEntity = netEntity;

        if (_trackedEntity == prevTrackedEntity)
            prevTrackedEntity = null;

        NavMap.Focus = _trackedEntity;
        _tryToScrollToListFocus = true;

        UpdateSensorsTable(_trackedEntity, prevTrackedEntity);
    }

    private void UpdateSensorsTable(NetEntity? currTrackedEntity, NetEntity? prevTrackedEntity)
    {
        foreach (var sensor in SensorsTable.Children)
        {
            if (sensor is not CrewMonitoringButton)
                continue;

            var castSensor = (CrewMonitoringButton) sensor;

            if (castSensor.SuitSensorUid == prevTrackedEntity)
                castSensor.RemoveStyleClass(StyleNano.StyleClassButtonColorGreen);

            else if (castSensor.SuitSensorUid == currTrackedEntity)
                castSensor.AddStyleClass(StyleNano.StyleClassButtonColorGreen);

            if (castSensor?.Coordinates == null)
                continue;

            if (NavMap.TrackedEntities.TryGetValue(castSensor.SuitSensorUid, out var data))
            {
                data = new NavMapBlip
                    (CoordinatesToLocal(data.Coordinates),
                    data.Texture,
                    (currTrackedEntity == null || castSensor.SuitSensorUid == currTrackedEntity) ? Color.LimeGreen : Color.LimeGreen * Color.DimGray,
                    castSensor.SuitSensorUid == currTrackedEntity);

                NavMap.TrackedEntities[castSensor.SuitSensorUid] = data;
            }
        }
    }

    private void TryToScrollToFocus()
    {
        if (!_tryToScrollToListFocus)
            return;

        if (TryGetNextScrollPosition(out float? nextScrollPosition))
        {
            SensorScroller.VScrollTarget = nextScrollPosition.Value;

            if (MathHelper.CloseToPercent(SensorScroller.VScroll, SensorScroller.VScrollTarget))
            {
                _tryToScrollToListFocus = false;
                return;
            }
        }
    }

    private bool TryGetNextScrollPosition([NotNullWhen(true)] out float? nextScrollPosition)
    {
        nextScrollPosition = 0;

        foreach (var sensor in SensorsTable.Children)
        {
            if (sensor is CrewMonitoringButton &&
                ((CrewMonitoringButton) sensor).SuitSensorUid == _trackedEntity)
                return true;

            nextScrollPosition += sensor.Height;
        }

        // Failed to find control
        nextScrollPosition = null;

        return false;
    }

    /// <summary>
    /// Converts the input coordinates to an EntityCoordinates which are in
    /// reference to the grid that the map is displaying. This is a stylistic
    /// choice; this window deliberately limits the rate that blips update,
    /// but if the blip is attached to another grid which is moving, that
    /// blip will move smoothly, unlike the others. By converting the
    /// coordinates, we are back in control of the blip movement.
    /// </summary>
    private EntityCoordinates CoordinatesToLocal(EntityCoordinates refCoords)
    {
        if (NavMap.MapUid != null)
        {
            return _transformSystem.WithEntityId(refCoords, (EntityUid)NavMap.MapUid);
        }
        else
        {
            return refCoords;
        }
    }

    private void ClearOutDatedData()
    {
        SensorsTable.RemoveAllChildren();
        NavMap.TrackedCoordinates.Clear();
        NavMap.TrackedEntities.Clear();
        NavMap.LocalizedNames.Clear();
    }
}

public sealed class CrewMonitoringButton : Button
{
    public int IndexInTable;
    public NetEntity SuitSensorUid;
    public EntityCoordinates? Coordinates;
}