// SPDX-FileCopyrightText: 2021 Fishfish458 <47410468+Fishfish458@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 2021 fishfish458 <fishfish458>
// SPDX-FileCopyrightText: 2021 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2022 Acruid <shatter66@gmail.com>
// SPDX-FileCopyrightText: 2022 Illiux <newoutlook@gmail.com>
// SPDX-FileCopyrightText: 2022 Jezithyr <Jezithyr@gmail.com>
// SPDX-FileCopyrightText: 2022 Kevin Zheng <kevinz5000@gmail.com>
// SPDX-FileCopyrightText: 2022 Moony <moonheart08@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Vera Aguilera Puerto <6766154+Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 2023 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 2023 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Jezithyr <jezithyr@gmail.com>
// SPDX-FileCopyrightText: 2023 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 2024 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2024 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2024 Alice "Arimah" Heurlin <30327355+arimah@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 HS <81934438+HolySSSS@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Rouge2t7 <81053047+Sarahon@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 2024 Truoizys <153248924+Truoizys@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 Verm <32827189+Vermidia@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 osjarw <62134478+osjarw@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 Арт <123451459+JustArt1m@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 AftrLite <61218133+AftrLite@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 CerberusWolfie <wb.johnb.willis@gmail.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 John Willis <143434770+CerberusWolfie@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Kayzel <43700376+KayzelW@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Lincoln McQueen <lincoln.mcqueen@gmail.com>
// SPDX-FileCopyrightText: 2025 Marcus F <199992874+thebiggestbruh@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Marcus F <marcus2008stoke@gmail.com>
// SPDX-FileCopyrightText: 2025 Misandry <mary@thughunt.ing>
// SPDX-FileCopyrightText: 2025 Roudenn <romabond091@gmail.com>
// SPDX-FileCopyrightText: 2025 Solstice <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 Spatison <137375981+Spatison@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Trest <144359854+trest100@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <linebarrelerenthusiast@gmail.com>
// SPDX-FileCopyrightText: 2025 gus <august.eymann@gmail.com>
// SPDX-FileCopyrightText: 2025 kurokoTurbo <92106367+kurokoTurbo@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 thebiggestbruh <199992874+thebiggestbruh@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 thebiggestbruh <marcus2008stoke@gmail.com>
// SPDX-FileCopyrightText: 2025 āda <ss.adasts@gmail.com>
// SPDX-FileCopyrightText: 2025 ThanosDeGraf <richardgirgindontstop@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using Content.Goobstation.Common.MartialArts;
using Content.Goobstation.Shared.Body; // goob
using Content.Server.Administration.Logs;
using Content.Server.Atmos.EntitySystems;
using Content.Server.Body.Components;
using Content.Server.Chat.Systems;
using Content.Server.EntityEffects.EffectConditions;
using Content.Server.EntityEffects.Effects;
using Content.Shared.Chemistry.EntitySystems;
using Content.Shared.Alert;
using Content.Shared.Atmos;
using Content.Shared.Body.Components;
using Content.Shared.Body.Prototypes;
using Content.Shared.Chat; // Einstein Engines - Language
using Content.Shared.Chemistry.Components;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.Damage;
using Content.Shared.Database;
using Content.Shared.EntityEffects;
using Content.Shared.Mobs.Systems;
using JetBrains.Annotations;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Content.Shared.Movement.Pulling.Components; // Goobstation
using Content.Shared.Movement.Pulling.Systems; // Goobstation
using Content.Goobstation.Shared.Body.Components;
using Content.Shared._DV.CosmicCult.Components; // DeltaV

// Shitmed Change
using Content.Shared._Shitmed.Targeting;
using Content.Shared._Shitmed.Body.Components;
using Content.Shared._Shitmed.Body.Organ;
using Content.Shared._Shitmed.Medical.Surgery.Consciousness;
using Content.Shared._Shitmed.Medical.Surgery.Consciousness.Systems;

namespace Content.Server.Body.Systems;

[UsedImplicitly]
public sealed class RespiratorSystem : EntitySystem
{
    [Dependency] private readonly IAdminLogManager _adminLogger = default!;
    [Dependency] private readonly IGameTiming _gameTiming = default!;
    [Dependency] private readonly AlertsSystem _alertsSystem = default!;
    [Dependency] private readonly AtmosphereSystem _atmosSys = default!;
    [Dependency] private readonly BodySystem _bodySystem = default!;
    [Dependency] private readonly DamageableSystem _damageableSys = default!;
    [Dependency] private readonly LungSystem _lungSystem = default!;
    [Dependency] private readonly MobStateSystem _mobState = default!;
    [Dependency] private readonly IPrototypeManager _protoMan = default!;
    [Dependency] private readonly SharedSolutionContainerSystem _solutionContainerSystem = default!;
    [Dependency] private readonly ChatSystem _chat = default!;
    [Dependency] private readonly ConsciousnessSystem _consciousness = default!; // Shitmed Change

    private static readonly ProtoId<MetabolismGroupPrototype> GasId = new("Gas");

    public override void Initialize()
    {
        base.Initialize();

        // We want to process lung reagents before we inhale new reagents.
        UpdatesAfter.Add(typeof(MetabolizerSystem));
        SubscribeLocalEvent<RespiratorComponent, MapInitEvent>(OnMapInit);
        SubscribeLocalEvent<RespiratorComponent, ApplyMetabolicMultiplierEvent>(OnApplyMetabolicMultiplier);

        // BodyComp stuff
        SubscribeLocalEvent<BodyComponent, InhaledGasEvent>(OnGasInhaled);
        SubscribeLocalEvent<BodyComponent, ExhaledGasEvent>(OnGasExhaled);
        SubscribeLocalEvent<BodyComponent, CanMetabolizeGasEvent>(CanBodyMetabolizeGas);
        SubscribeLocalEvent<BodyComponent, SuffocationEvent>(OnSuffocation);
        SubscribeLocalEvent<BodyComponent, StopSuffocatingEvent>(OnStopSuffocating);
    }

    // Goobstation start
    // Can breathe check for grab or if they need air
    public bool CanBreathe(EntityUid uid, RespiratorComponent respirator)
    {
        var airEv = new CheckNeedsAirEvent();
        RaiseLocalEvent(uid, ref airEv);

        if (airEv.Cancelled)
            return true;

        if (respirator.Saturation < respirator.SuffocationThreshold)
            return false;
        if (TryComp<PullableComponent>(uid, out var pullable)
            && pullable.GrabStage == GrabStage.Suffocate)
            return false;

        return !HasComp<KravMagaBlockedBreathingComponent>(uid);
    }
    // Goobstation end
    private void OnMapInit(Entity<RespiratorComponent> ent, ref MapInitEvent args)
    {
        ent.Comp.NextUpdate = _gameTiming.CurTime + ent.Comp.AdjustedUpdateInterval;
    }

    public override void Update(float frameTime)
    {
        base.Update(frameTime);

        var query = EntityQueryEnumerator<RespiratorComponent, BodyComponent>();
        while (query.MoveNext(out var uid, out var respirator, out var body))
        {
            if (_gameTiming.CurTime < respirator.NextUpdate)
                continue;

            respirator.NextUpdate += respirator.AdjustedUpdateInterval;

            if (_mobState.IsDead(uid) || HasComp<BreathingImmunityComponent>(uid) || HasComp<SpecialBreathingImmunityComponent>(uid)) // Shitmed: BreathingImmunity
                continue;

            // Begin DeltaV Code: Addition:
            var organs = _bodySystem.GetBodyOrganEntityComps<LungComponent>((uid, body));
            var multiplier = -1f;
            foreach (var (_, lung, _) in organs)
            {
                multiplier *= lung.SaturationLoss * respirator.SaturationLoss; // Goob Edit - In a DeltaV Edit :o
            }
            // End DeltaV Code
            UpdateSaturation(uid,  multiplier * (float) respirator.UpdateInterval.TotalSeconds, respirator); // DeltaV: use multiplier instead of negating

            if (!_mobState.IsIncapacitated(uid) && !HasComp<DebrainedComponent>(uid)) // Shitmed Change - Cannot breathe in crit or when no brain.
            {
                switch (respirator.Status)
                {
                    case RespiratorStatus.Inhaling:
                        Inhale((uid, respirator));
                        respirator.Status = RespiratorStatus.Exhaling;
                        break;
                    case RespiratorStatus.Exhaling:
                        Exhale((uid, respirator));
                        respirator.Status = RespiratorStatus.Inhaling;
                        break;
                }
            }

            if (!CanBreathe(uid, respirator)) // Goobstation edit
            {
                // DeltaV: Cosmic Cult - One line change but a refactor would be better. this is kinda cringe.
                // Makes cultists gasp and respirate but not asphyxiate in space.
                if (TryComp<CosmicCultComponent>(uid, out var cultComponent)
                    && !cultComponent.Respiration
                    && !_mobState.IsIncapacitated(uid))
                    return;

                if (_gameTiming.CurTime >= respirator.LastGaspEmoteTime + respirator.GaspEmoteCooldown)
                {
                    respirator.LastGaspEmoteTime = _gameTiming.CurTime;
                    _chat.TryEmoteWithChat(uid,
                        respirator.GaspEmote,
                        ChatTransmitRange.HideChat,
                        ignoreActionBlocker: true);
                }

                TakeSuffocationDamage((uid, respirator));
                respirator.SuffocationCycles += 1;
                continue;
            }

            StopSuffocation((uid, respirator));
            respirator.SuffocationCycles = 0;
        }
    }

    public void Inhale(Entity<RespiratorComponent?> entity)
    {
        if (!Resolve(entity, ref entity.Comp, logMissing: false))
            return;

        // Inhale gas
        var ev = new InhaleLocationEvent
        {
            Respirator = entity.Comp,
        };
        RaiseLocalEvent(entity, ref ev);

        ev.Gas ??= _atmosSys.GetContainingMixture(entity.Owner, excite: true);

        if (ev.Gas is null)
            return;

        var gas = ev.Gas.RemoveVolume(entity.Comp.BreathVolume);

        var inhaleEv = new InhaledGasEvent(gas);
        RaiseLocalEvent(entity, ref inhaleEv);

        if (inhaleEv.Handled && inhaleEv.Succeeded)
            return;

        // If nothing could inhale the gas give it back.
        _atmosSys.Merge(ev.Gas, gas);
    }

    public void Exhale(Entity<RespiratorComponent> entity)
    {
        // exhale gas

        var ev = new ExhaleLocationEvent();
        RaiseLocalEvent(entity, ref ev, broadcast: false);

        if (ev.Gas is null)
        {
            ev.Gas = _atmosSys.GetContainingMixture(entity.Owner, excite: true);

            // Walls and grids without atmos comp return null. I guess it makes sense to not be able to exhale in walls,
            // but this also means you cannot exhale on some grids.
            ev.Gas ??= GasMixture.SpaceGas;
        }

        Exhale(entity!, ev.Gas);
    }

    public void Exhale(Entity<RespiratorComponent?> entity, GasMixture gas)
    {
        if (!Resolve(entity, ref entity.Comp, logMissing: false))
            return;

        var ev = new ExhaledGasEvent(gas);
        RaiseLocalEvent(entity, ref ev);
    }

    /// <summary>
    /// Returns true if the entity is above their SuffocationThreshold and alive.
    /// </summary>
    public bool IsBreathing(Entity<RespiratorComponent?> ent)
    {
        if (_mobState.IsIncapacitated(ent))
            return false;

        if (!Resolve(ent, ref ent.Comp))
            return false;

        return (ent.Comp.Saturation > ent.Comp.SuffocationThreshold);
    }

    /// <summary>
    /// Checks if it's safe for a given entity to breathe the air from the environment it is currently situated in.
    /// </summary>
    /// <param name="ent">The entity attempting to metabolize the gas.</param>
    /// <returns>Returns true only if the air is not toxic, and it wouldn't suffocate.</returns>
    public bool CanMetabolizeInhaledAir(Entity<RespiratorComponent?> ent)
    {
        if (!Resolve(ent, ref ent.Comp))
            return false;

        // Get the gas at our location but don't actually remove it from the gas mixture.
        var ev = new InhaleLocationEvent
        {
            Respirator = ent.Comp,
        };
        RaiseLocalEvent(ent, ref ev);

        ev.Gas ??= _atmosSys.GetContainingMixture(ent.Owner, excite: true);

        // If there's no air to breathe or we can't metabolize it then internals should be on.
        return ev.Gas is not null && CanMetabolizeInhaledAir(ent, ev.Gas);
    }

    /// <summary>
    /// Checks if a given entity can safely metabolize a given gas mixture.
    /// </summary>
    /// <param name="ent">The entity attempting to metabolize the gas.</param>
    /// <param name="gas">The gas mixture we are trying to metabolize.</param>
    /// <returns>Returns true only if the gas mixture is not toxic, and it wouldn't suffocate.</returns>
    public bool CanMetabolizeInhaledAir(Entity<RespiratorComponent?> ent, GasMixture gas)
    {
        if (!Resolve(ent, ref ent.Comp))
            return false;

        var ev = new CanMetabolizeGasEvent(gas);
        RaiseLocalEvent(ent, ref ev);

        if (!ev.Handled || ev.Toxic)
            return false;

        return ev.Saturation > ent.Comp.UpdateInterval.TotalSeconds;
    }

    /// <summary>
    /// Tries to safely metabolize the current solutions in a body's lungs.
    /// </summary>
    private void CanBodyMetabolizeGas(Entity<BodyComponent> ent, ref CanMetabolizeGasEvent args)
    {
        if (args.Handled)
            return;

        var organs = _bodySystem.GetBodyOrganEntityComps<LungComponent>((ent, null));
        if (organs.Count == 0)
            return;

        var solution = _lungSystem.GasToReagent(args.Gas);

        var saturation = 0f;
        foreach (var organ in organs)
        {
            saturation += GetSaturation(solution, organ.Owner, out var toxic);
            if (!toxic)
                continue;

            args.Handled = true;
            args.Toxic = true;
            return;
        }

        args.Handled = true;
        args.Saturation = saturation;
    }

    public bool TryInhaleGasToBody(Entity<BodyComponent?> entity, GasMixture gas)
    {
        if (!Resolve(entity, ref entity.Comp))
            return false;

        var organs = _bodySystem.GetBodyOrganEntityComps<LungComponent>((entity, entity.Comp));
        if (organs.Count == 0)
            return false;

        var lungRatio = 1.0f / organs.Count;
        var splitGas = organs.Count == 1 ? gas : gas.RemoveRatio(lungRatio);
        foreach (var (organUid, lung, _) in organs)
        {
            // Merge doesn't remove gas from the giver.
            _atmosSys.Merge(lung.Air, splitGas);
            _lungSystem.GasToReagent(organUid, lung);
        }

        return true;
    }

    public void RemoveGasFromBody(Entity<BodyComponent> ent, GasMixture gas)
    {
        var outGas = new GasMixture(gas.Volume);

        var organs = _bodySystem.GetBodyOrganEntityComps<LungComponent>((ent, ent.Comp));
        if (organs.Count == 0)
            return;

        foreach (var (organUid, lung, _) in organs)
        {
            _atmosSys.Merge(outGas, lung.Air);
            lung.Air.Clear();

            if (_solutionContainerSystem.ResolveSolution(organUid, lung.SolutionName, ref lung.Solution))
                _solutionContainerSystem.RemoveAllSolution(lung.Solution.Value);
        }

        _atmosSys.Merge(gas, outGas);
    }

    /// <summary>
    /// Get the amount of saturation that would be generated if the lung were to metabolize the given solution.
    /// </summary>
    /// <remarks>
    /// This assumes the metabolism rate is unbounded, which generally should be the case for lungs, otherwise we get
    /// back to the old pulmonary edema bug.
    /// </remarks>
    /// <param name="solution">The reagents to metabolize</param>
    /// <param name="lung">The entity doing the metabolizing</param>
    /// <param name="toxic">Whether or not any of the reagents would deal damage to the entity</param>
    private float GetSaturation(Solution solution, Entity<MetabolizerComponent?> lung, out bool toxic)
    {
        toxic = false;
        if (!Resolve(lung, ref lung.Comp))
            return 0;

        if (lung.Comp.MetabolismGroups == null)
            return 0;

        float saturation = 0;
        foreach (var (id, quantity) in solution.Contents)
        {
            var reagent = _protoMan.Index<ReagentPrototype>(id.Prototype);
            if (reagent.Metabolisms == null)
                continue;

            if (!reagent.Metabolisms.TryGetValue(GasId, out var entry))
                continue;

            foreach (var effect in entry.Effects)
            {
                if (effect is HealthChange health)
                    toxic |= CanMetabolize(health) && health.Damage.AnyPositive();
                else if (effect is Oxygenate oxy && CanMetabolize(oxy))
                    saturation += oxy.Factor * quantity.Float();
            }
        }

        // TODO generalize condition checks
        // this is pretty janky, but I just want to bodge a method that checks if an entity can breathe a gas mixture
        // Applying actual reaction effects require a full ReagentEffectArgs struct.
        bool CanMetabolize(EntityEffect effect)
        {
            if (effect.Conditions == null)
                return true;

            foreach (var cond in effect.Conditions)
            {
                if (cond is OrganType organ && !organ.Condition(lung, EntityManager))
                    return false;
            }

            return true;
        }

        return saturation;
    }

    private void TakeSuffocationDamage(Entity<RespiratorComponent> ent)
    {
        if (ent.Comp.SuffocationCycles == 2)
            _adminLogger.Add(LogType.Asphyxiation, $"{ToPrettyString(ent):entity} started suffocating");

        // Shitmed Change Start
        if (_consciousness.TryGetNerveSystem(ent, out var nerveSys))
        {
            if (!_consciousness.TryGetConsciousnessModifier(ent, nerveSys.Value, out var modifier, "Suffocation"))
            {
                _consciousness.AddConsciousnessModifier(
                    ent,
                    nerveSys.Value,
                    -ent.Comp.Damage.GetTotal(),
                    identifier: "Suffocation",
                    type: ConsciousnessModType.Pain);
            }
            else
            {
                _consciousness.SetConsciousnessModifier(
                    ent,
                    nerveSys.Value,
                    modifier.Value.Change - ent.Comp.Damage.GetTotal(),
                    identifier: "Suffocation",
                    type: ConsciousnessModType.Pain);
            }
        }

        // Shitmed Change End
        _damageableSys.TryChangeDamage(ent, HasComp<DebrainedComponent>(ent) ? ent.Comp.Damage * 4.5f : ent.Comp.Damage, targetPart: TargetBodyPart.Vital, interruptsDoAfters: false); // Shitmed Change + Goobstation

        if (ent.Comp.SuffocationCycles < ent.Comp.SuffocationCycleThreshold)
            return;

        var ev = new SuffocationEvent();
        RaiseLocalEvent(ent, ref ev);
    }

    private void StopSuffocation(Entity<RespiratorComponent> ent)
    {
        if (ent.Comp.SuffocationCycles >= 2)
            _adminLogger.Add(LogType.Asphyxiation, $"{ToPrettyString(ent):entity} stopped suffocating");

        _damageableSys.TryChangeDamage(ent, ent.Comp.DamageRecovery);

        var ev = new StopSuffocatingEvent();
        RaiseLocalEvent(ent, ref ev);
    }

    private void OnSuffocation(Entity<BodyComponent> ent, ref SuffocationEvent args)
    {
        // TODO: This is not going work with multiple different lungs, if that ever becomes a possibility
        var organs = _bodySystem.GetBodyOrganEntityComps<LungComponent>((ent, null));
        foreach (var entity in organs)
        {
            _alertsSystem.ShowAlert(ent, entity.Comp1.Alert);
        }
    }

    private void OnStopSuffocating(Entity<BodyComponent> ent, ref StopSuffocatingEvent args)
    {
        // TODO: This is not going work with multiple different lungs, if that ever becomes a possibility
        var organs = _bodySystem.GetBodyOrganEntityComps<LungComponent>((ent, null));
        foreach (var entity in organs)
        {
            _alertsSystem.ClearAlert(ent, entity.Comp1.Alert);
        }

        if (!TryComp<RespiratorComponent>(ent.Owner, out var respirator))
            return;

        // Shitmed Change Start
        if (_consciousness.TryGetNerveSystem(ent, out var nerveSys)
            && _consciousness.TryGetConsciousnessModifier(ent, nerveSys.Value, out var modifier, "Suffocation"))
        {
            if (modifier.Value.Change < respirator.DamageRecovery.GetTotal())
            {
                _consciousness.RemoveConsciousnessModifier(ent, nerveSys.Value, "Suffocation");
            }
            else
            {
                _consciousness.SetConsciousnessModifier(
                    ent,
                    nerveSys.Value,
                    modifier.Value.Change + respirator.DamageRecovery.GetTotal(),
                    identifier: "Suffocation",
                    type: ConsciousnessModType.Pain);
            }
        }

        _damageableSys.TryChangeDamage(ent, respirator.DamageRecovery, targetPart: TargetBodyPart.All, ignoreBlockers: true);
        // Shitmed Change End
    }

    public void UpdateSaturation(EntityUid uid, float amount, RespiratorComponent? respirator = null)
    {
        if (!Resolve(uid, ref respirator, false))
            return;

        // Goob start
        var airEv = new CheckNeedsAirEvent();
        RaiseLocalEvent(uid, ref airEv);

        if (airEv.Cancelled)
            return;
        // Goob end

        respirator.Saturation += amount;
        respirator.Saturation =
            Math.Clamp(respirator.Saturation, respirator.MinSaturation, respirator.MaxSaturation);
    }

    private void OnApplyMetabolicMultiplier(Entity<RespiratorComponent> ent, ref ApplyMetabolicMultiplierEvent args)
    {
        ent.Comp.UpdateIntervalMultiplier = args.Multiplier;
    }

    private void OnGasInhaled(Entity<BodyComponent> entity, ref InhaledGasEvent args)
    {
        if (args.Handled)
            return;

        args.Handled = true;

        args.Succeeded = TryInhaleGasToBody((entity, entity.Comp), args.Gas);
    }

    private void OnGasExhaled(Entity<BodyComponent> entity, ref ExhaledGasEvent args)
    {
        if (args.Handled)
            return;

        args.Handled = true;

        RemoveGasFromBody(entity, args.Gas);
    }
}

/// <summary>
/// Event raised when an entity first tries to inhale that returns a GasMixture from a given location.
/// </summary>
/// <param name="Gas">The gas that gets returned, null if there is none.</param>
/// <param name="Respirator">The Respirator component of the entity attempting to inhale</param>
[ByRefEvent]
public record struct InhaleLocationEvent(GasMixture? Gas, RespiratorComponent Respirator);

/// <summary>
/// Event raised when an entity first tries to exhale a gas, determines where the gas they're exhaling will be sent.
/// </summary>
/// <param name="Gas">The gas mixture that the exhaled gas will be merged into.</param>
[ByRefEvent]
public record struct ExhaleLocationEvent(GasMixture? Gas);

/// <summary>
/// Event raised when an entity successfully inhales a gas, attempts to find a place to put the gas.
/// </summary>
/// <param name="Gas">The gas we're inhaling.</param>
/// <param name="Handled">Whether a system has responded appropriately.</param>
/// <param name="Succeeded">Whether we successfully managed to inhale the gas</param>
[ByRefEvent]
public record struct InhaledGasEvent(GasMixture Gas, bool Handled = false, bool Succeeded = false);

/// <summary>
/// Event raised when an entity is exhaling
/// </summary>
/// <param name="Gas">The gas mixture we're exhaling into.</param>
/// <param name="Handled">Whether we have successfully exhaled or not.</param>
[ByRefEvent]
public record struct ExhaledGasEvent(GasMixture Gas, bool Handled = false);

/// <summary>
/// Raised when an entity starts suffocating and when suffocation progresses.
/// </summary>
[ByRefEvent]
public record struct SuffocationEvent;

/// <summary>
/// Raised when an entity that was suffocating stops suffocating.
/// </summary>
[ByRefEvent]
public record struct StopSuffocatingEvent;

/// <summary>
/// An event raised to inhalation handlers that asks them nicely to simulate what it would be like to metabolize
/// a given volume of gas, without actually metabolizing it.
/// </summary>
/// <param name="Gas">The gas mixture we are testing.</param>
/// <param name="Toxic">Whether the gas returns as toxic to any respirator.</param>
/// <param name="Saturation">The amount of saturation we got from the gas.</param>
[ByRefEvent]
public record struct CanMetabolizeGasEvent(GasMixture Gas, bool Toxic = false, float Saturation = 0f, bool Handled = false);
