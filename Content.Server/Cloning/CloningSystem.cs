// SPDX-FileCopyrightText: 2020 Exp <theexp111@gmail.com>
// SPDX-FileCopyrightText: 2020 SoulSloth <67545203+SoulSloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 20kdc <asdd2808@gmail.com>
// SPDX-FileCopyrightText: 2021 Acruid <shatter66@gmail.com>
// SPDX-FileCopyrightText: 2021 Galactic Chimp <63882831+GalacticChimp@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Metal Gear Sloth <metalgearsloth@gmail.com>
// SPDX-FileCopyrightText: 2021 Silver <silvertorch5@gmail.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <6766154+Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 2021 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2022 EmoGarbage404 <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Flipp Syder <76629141+vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Javier Guardia Fernï¿½ndez <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Moony <moonheart08@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2022 fishfish458 <fishfish458>
// SPDX-FileCopyrightText: 2022 och-och <80923370+och-och@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 AJCM-git <60196617+AJCM-git@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 2023 ElectroJr <leonsfriedrich@gmail.com>
// SPDX-FileCopyrightText: 2023 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Jezithyr <jezithyr@gmail.com>
// SPDX-FileCopyrightText: 2023 Julian Giebel <juliangiebel@live.de>
// SPDX-FileCopyrightText: 2023 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 OctoRocket <88291550+OctoRocket@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 2023 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 brainfood1183 <113240905+brainfood1183@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 corentt <36075110+corentt@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 keronshb <54602815+keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Scribbles0 <91828755+Scribbles0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 2024 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 username <113782077+whateverusername0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 whateverusername0 <whateveremail>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 CerberusWolfie <wb.johnb.willis@gmail.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 John Willis <143434770+CerberusWolfie@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Mnemotechnican <69920617+Mnemotechnician@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 SX-7 <sn1.test.preria.2002@gmail.com>
// SPDX-FileCopyrightText: 2025 ScarKy0 <106310278+ScarKy0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Solstice <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 SolsticeOfTheWinter <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 Ted Lukin <66275205+pheenty@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2025 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 pheenty <fedorlukin2006@gmail.com>
// SPDX-FileCopyrightText: 2025 poklj <compgeek223@gmail.com>
// SPDX-FileCopyrightText: 2025 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using Content.Goobstation.Common.Cloning;
using Content.Server.Humanoid;
using Content.Shared.Administration.Logs;
using Content.Shared.Cloning;
using Content.Shared.Cloning.Events;
using Content.Shared.Database;
using Content.Shared.Humanoid;
using Content.Shared.Humanoid.Prototypes;
using Content.Shared.Inventory;
using Content.Shared.Implants;
using Content.Shared.Implants.Components;
using Content.Shared.NameModifier.EntitySystems;
using Content.Shared.StatusEffect;
using Content.Shared.Storage;
using Content.Shared.Storage.EntitySystems;
using Content.Shared.Whitelist;
using Robust.Shared.Containers;
using Robust.Shared.Map;
using Robust.Shared.Prototypes;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Content.Goobstation.Shared.CloneProjector.Clone;
using Content.Goobstation.Shared.Clothing.Components;
using Content.Goobstation.Shared.Clothing.Systems;
using Content.Shared.Clothing.Components;
using Content.Shared.Clothing.EntitySystems;
using Content.Shared.Interaction.Components;
using Content.Shared.Radio.Components; // Goobstation
using Content.Shared.Radio.EntitySystems;
using Robust.Shared.Utility; // Goobstation

namespace Content.Server.Cloning;

/// <summary>
///     System responsible for making a copy of a humanoid's body.
///     For the cloning machines themselves look at CloningPodSystem, CloningConsoleSystem and MedicalScannerSystem instead.
/// </summary>
public sealed partial class CloningSystem : EntitySystem
{
    [Dependency] private readonly HumanoidAppearanceSystem _humanoidSystem = default!;
    [Dependency] private readonly InventorySystem _inventory = default!;
    [Dependency] private readonly MetaDataSystem _metaData = default!;
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly EntityWhitelistSystem _whitelist = default!;
    [Dependency] private readonly ISharedAdminLogManager _adminLogger = default!;
    [Dependency] private readonly SharedContainerSystem _container = default!;
    [Dependency] private readonly SharedStorageSystem _storage = default!;
    [Dependency] private readonly SharedSubdermalImplantSystem _subdermalImplant = default!;
    [Dependency] private readonly NameModifierSystem _nameMod = default!;
    [Dependency] private readonly ToggleableClothingSystem _toggleable = default!; // Goobstation
    [Dependency] private readonly SharedSealableClothingSystem _sealable = default!; // Goobstation

    /// <summary>
    ///     Spawns a clone of the given humanoid mob at the specified location or in nullspace.
    /// </summary>
    public bool TryCloning(EntityUid original, MapCoordinates? coords, ProtoId<CloningSettingsPrototype> settingsId, [NotNullWhen(true)] out EntityUid? clone)
    {
        clone = null;
        if (!_prototype.TryIndex(settingsId, out var settings))
            return false; // invalid settings

        // Goobstation start
        if (!TryComp<HumanoidAppearanceComponent>(original, out var humanoid) && !settings.AllowNonHumanoid)
            return false; // whatever body was to be cloned, was not a humanoid

        SpeciesPrototype? speciesPrototype = null;
        if (humanoid != null && !_prototype.TryIndex(humanoid.Species, out speciesPrototype))
            return false; // invalid species

        var proto = speciesPrototype?.Prototype.ToString() ?? Prototype(original)?.ID;
        if (proto == null)
            return false;
        // Goobstation end

        if (HasComp<HolographicCloneComponent>(original) && !settings.ForceCloning) // Goobstation - This has to be separate because I don't want to touch the other check.
            return false;

        if (HasComp<UncloneableComponent>(original) && !settings.ForceCloning) // Goob: enable forcecloning bypass for antagctrl admemes on vox/ipc.
            return false; // Goobstation: Don't clone IPCs and voxes. It could be argued it should be in the CloningPodSystem instead

        var attemptEv = new CloningAttemptEvent(settings);
        RaiseLocalEvent(original, ref attemptEv);
        if (attemptEv.Cancelled && !settings.ForceCloning)
            return false; // cannot clone, for example due to the unrevivable trait

        clone = coords == null ? Spawn(proto) : Spawn(proto, coords.Value); // Goob edit
        _humanoidSystem.CloneAppearance(original, clone.Value);

        CloneComponents(original, clone.Value, settings);

        // Add equipment first so that SetEntityName also renames the ID card.
        if (settings.CopyEquipment != null)
            CopyEquipment(original, clone.Value, settings.CopyEquipment.Value, settings.Whitelist, settings.Blacklist, settings.MakeEquipmentUnremoveable, settings.CopyStorage, settings.InternalContentsUnremoveable); // Goob edit

        // Copy storage on the mob itself as well.
        // This is needed for slime storage.
        if (settings.CopyInternalStorage)
            CopyStorage(original, clone.Value, settings.Whitelist, settings.Blacklist);

        // copy implants and their storage contents
        if (settings.CopyImplants)
            CopyImplants(original, clone.Value, settings.CopyInternalStorage, settings.Whitelist, settings.Blacklist);

        var originalName = _nameMod.GetBaseName(original);

        // Set the clone's name. The raised events will also adjust their PDA and ID card names.
        _metaData.SetEntityName(clone.Value, originalName);

        _adminLogger.Add(LogType.Chat, LogImpact.Medium, $"The body of {original:player} was cloned as {clone.Value:player}");
        return true;
    }

    /// <summary>
    ///     Copy components from one entity to another based on a CloningSettingsPrototype.
    /// </summary>
    /// <param name="original">The orignal Entity to clone components from.</param>
    /// <param name="clone">The target Entity to clone components to.</param>
    /// <param name="settings">The clone settings prototype containing the list of components to clone.</param>
    public void CloneComponents(EntityUid original, EntityUid clone, CloningSettingsPrototype settings)
    {
        var componentsToCopy = settings.Components;
        var componentsToEvent = settings.EventComponents;

        // don't make status effects permanent
        if (TryComp<StatusEffectsComponent>(original, out var statusComp))
        {
            var statusComps = statusComp.ActiveEffects.Values.Select(s => s.RelevantComponent).Where(s => s != null).ToList();
            componentsToCopy.ExceptWith(statusComps!);
            componentsToEvent.ExceptWith(statusComps!);
        }

        // Goobstation Start
        // Ensure EncryptionKeyHolderComponent is in the components to copy if it exists on the original
        if (HasComp<EncryptionKeyHolderComponent>(original) &&
            TryComp<EncryptionKeyHolderComponent>(original, out var originalKeyHolder) &&
            TryComp<EncryptionKeyHolderComponent>(clone, out var cloneKeyHolder))
        {
            // The component is already copied by the cloning system, we just need to copy the keys
            var originalContainer = originalKeyHolder.KeyContainer;
            var cloneContainer = cloneKeyHolder.KeyContainer;

            // Clear any existing keys in the clone
            _container.CleanContainer(cloneContainer);

            // Copy each key from original to clone
            foreach (var key in originalContainer.ContainedEntities.ToList())
            {
                if (!Exists(key))
                    continue;

                // Create a new instance of the key
                if (MetaData(key).EntityPrototype is { } proto)
                {
                    var newKey = Spawn(proto.ID, Transform(clone).Coordinates);
                    if (!_container.Insert(newKey, cloneContainer))
                    {
                        Log.Warning($"Failed to insert key {ToPrettyString(newKey)} into clone's container");
                        Del(newKey);
                    }
                }
            }
            // Update the encryption channels on the clone
            var encSystem = EntityManager.System<EncryptionKeySystem>();
            encSystem.UpdateChannels(clone, cloneKeyHolder);
        }
        // Goobstation End

        foreach (var componentName in componentsToCopy)
        {
            if (!Factory.TryGetRegistration(componentName, out var componentRegistration))
            {
                Log.Error($"Tried to use invalid component registration for cloning: {componentName}");
                continue;
            }

            // If the original does not have the component, then the clone shouldn't have it either.
            RemComp(clone, componentRegistration.Type);
            if (EntityManager.TryGetComponent(original, componentRegistration.Type, out var sourceComp)) // Does the original have this component?
            {
                CopyComp(original, clone, sourceComp);
            }
        }

        foreach (var componentName in componentsToEvent)
        {
            if (!Factory.TryGetRegistration(componentName, out var componentRegistration))
            {
                Log.Error($"Tried to use invalid component registration for cloning: {componentName}");
                continue;
            }

            // If the original does not have the component, then the clone shouldn't have it either.
            RemComp(clone, componentRegistration.Type);
        }

        var cloningEv = new CloningEvent(settings, clone);
        RaiseLocalEvent(original, ref cloningEv); // used for datafields that cannot be directly copied using CopyComp
    }

    /// <summary>
    ///     Copies the equipment the original has to the clone.
    ///     This uses the original prototype of the items, so any changes to components that are done after spawning are lost!
    /// </summary>
    public void CopyEquipment(Entity<InventoryComponent?> original, Entity<InventoryComponent?> clone, SlotFlags slotFlags, EntityWhitelist? whitelist = null, EntityWhitelist? blacklist = null, bool makeUnremoveable = false, bool copyStorage = true, bool internalContentsUnremoveable = false) // Goob edit
    {
        if (!Resolve(original, ref original.Comp) || !Resolve(clone, ref clone.Comp))
            return;

        var coords = Transform(clone).Coordinates;

        // Iterate over all inventory slots
        var slotEnumerator = _inventory.GetSlotEnumerator(original, slotFlags);
        while (slotEnumerator.NextItem(out var item, out var slot))
        {
            var cloneItem = CopyItem(item, coords, whitelist, blacklist, copyStorage);

            // Goob edit start
            if (cloneItem == null)
                continue;

            if (!_inventory.TryEquip(clone, cloneItem.Value, slot.Name, silent: true, inventory: clone.Comp))
            {
                Del(cloneItem); // delete it again if the clone cannot equip it
                continue;
            }

            if (makeUnremoveable)
                EnsureComp<UnremoveableComponent>(cloneItem.Value);

            if (internalContentsUnremoveable && TryComp(cloneItem.Value, out ContainerManagerComponent? manager))
            {
                foreach (var container in manager.Containers.Values)
                {
                    foreach (var contained in container.ContainedEntities)
                    {
                        if (!HasComp<AttachedClothingComponent>(contained))
                            EnsureComp<UnremoveableComponent>(contained);
                    }
                }
            }

            if (!TryComp(item, out ToggleableClothingComponent? toggleable) || toggleable.ClothingUids.Count == 0 ||
                !TryComp(cloneItem.Value, out ToggleableClothingComponent? clonedToggleable))
                continue;

            var allEquipped = true;
            List<EntityUid> equipped = new();
            foreach (var (clothing, toggleSlot) in toggleable.ClothingUids)
            {
                if (!_toggleable.IsToggled((item, toggleable), clothing))
                {
                    allEquipped = false;
                    continue;
                }

                if (clonedToggleable.ClothingUids.FirstOrNull(kvp => kvp.Value == toggleSlot) is not
                    { } newClothing)
                {
                    allEquipped = false;
                    continue;
                }

                if (_toggleable.EquipClothing(clone.Owner,
                        (cloneItem.Value, clonedToggleable),
                        newClothing.Key,
                        newClothing.Value,
                        true))
                    equipped.Add(newClothing.Key);
            }

            if (!allEquipped || !TryComp(item, out SealableClothingControlComponent? sealable) ||
                !sealable.IsCurrentlySealed ||
                !TryComp(cloneItem.Value, out SealableClothingControlComponent? clonedSealable))
                continue;

            var success = true;
            foreach (var toSeal in equipped)
            {
                if (!_sealable.SealPart(toSeal, (cloneItem.Value, clonedSealable), true))
                {
                    success = false;
                    break;
                }
            }

            if (success)
                _sealable.EndSealProcess((cloneItem.Value, clonedSealable), true);
            // Goob edit end
        }
    }

    /// <summary>
    ///     Copies an item and its storage recursively, placing all items at the same position in grid storage.
    ///     This uses the original prototype of the items, so any changes to components that are done after spawning are lost!
    /// </summary>
    /// <remarks>
    ///     This is not perfect and only considers item in storage containers.
    ///     Some components have their own additional spawn logic on map init, so we cannot just copy all containers.
    /// </remarks>
    public EntityUid? CopyItem(EntityUid original, EntityCoordinates coords, EntityWhitelist? whitelist = null, EntityWhitelist? blacklist = null, bool copyStorage = true) // Goob edit
    {
        // we use a whitelist and blacklist to be sure to exclude any problematic entities
        if (!_whitelist.CheckBoth(original, blacklist, whitelist))
            return null;

        var prototype = MetaData(original).EntityPrototype?.ID;
        if (prototype == null)
            return null;

        var spawned = SpawnAtPosition(prototype, coords);

        // copy over important component data
        var ev = new CloningItemEvent(spawned);
        RaiseLocalEvent(original, ref ev);

        // if the original has items inside its storage, copy those as well
        if (TryComp<StorageComponent>(original, out var originalStorage) && TryComp<StorageComponent>(spawned, out var spawnedStorage)) // Goob edit
        {
            // remove all items that spawned with the entity inside its storage
            // this ignores other containers, but this should be good enough for our purposes
            _container.CleanContainer(spawnedStorage.Container);

            if (!copyStorage) // Goobstation
                return spawned;

            // recursively replace them
            // surely no one will ever create two items that contain each other causing an infinite loop, right?
            foreach ((var itemUid, var itemLocation) in originalStorage.StoredItems)
            {
                var copy = CopyItem(itemUid, coords, whitelist, blacklist);
                if (copy != null)
                    _storage.InsertAt((spawned, spawnedStorage), copy.Value, itemLocation, out _, playSound: false);
            }
        }

        return spawned;
    }

    /// <summary>
    ///     Copies an item's storage recursively to another storage.
    ///     The storage grids should have the same shape or it will drop on the floor.
    ///     Basically the same as CopyItem, but we don't copy the outermost container.
    /// </summary>
    public void CopyStorage(Entity<StorageComponent?> original, Entity<StorageComponent?> target, EntityWhitelist? whitelist = null, EntityWhitelist? blacklist = null)
    {
        if (!Resolve(original, ref original.Comp, false) || !Resolve(target, ref target.Comp, false))
            return;

        var coords = Transform(target).Coordinates;

        // delete all items in the target storage
        _container.CleanContainer(target.Comp.Container);

        // recursively replace them
        foreach ((var itemUid, var itemLocation) in original.Comp.StoredItems)
        {
            var copy = CopyItem(itemUid, coords, whitelist, blacklist);
            if (copy != null)
                _storage.InsertAt(target, copy.Value, itemLocation, out _, playSound: false);
        }
    }

    /// <summary>
    ///     Copies all implants from one mob to another.
    ///     Might result in duplicates if the target already has them.
    ///     Can copy the storage inside a storage implant according to a whitelist and blacklist.
    /// </summary>
    /// <param name="original">Entity to copy implants from.</param>
    /// <param name="target">Entity to copy implants to.</param>
    /// <param name="copyStorage">If true will copy storage of the implants (E.g storage implant)</param>
    /// <param name="whitelist">Whitelist for the storage copy (If copyStorage is true)</param>
    /// <param name="blacklist">Blacklist for the storage copy (If copyStorage is true)</param>
    public void CopyImplants(Entity<ImplantedComponent?> original, EntityUid target, bool copyStorage = false, EntityWhitelist? whitelist = null, EntityWhitelist? blacklist = null)
    {
        if (!Resolve(original, ref original.Comp, false))
            return; // they don't have any implants to copy!

        foreach (var originalImplant in original.Comp.ImplantContainer.ContainedEntities)
        {
            if (!HasComp<SubdermalImplantComponent>(originalImplant))
                continue; // not an implant (should only happen with admin shenanigans)

            var implantId = MetaData(originalImplant).EntityPrototype?.ID;

            if (implantId == null)
                continue;

            var targetImplant = _subdermalImplant.AddImplant(target, implantId);

            if (targetImplant == null)
                continue;

            // copy over important component data
            var ev = new CloningItemEvent(targetImplant.Value);
            RaiseLocalEvent(originalImplant, ref ev);

            if (copyStorage)
                CopyStorage(originalImplant, targetImplant.Value, whitelist, blacklist); // only needed for storage implants
        }

    }
}
