// SPDX-FileCopyrightText: 2019 Remie Richards <remierichards@gmail.com>
// SPDX-FileCopyrightText: 2019 moneyl <8206401+Moneyl@users.noreply.github.com>
// SPDX-FileCopyrightText: 2020 Exp <theexp111@gmail.com>
// SPDX-FileCopyrightText: 2020 PrPleGoo <felix.leeuwen@gmail.com>
// SPDX-FileCopyrightText: 2020 VÃ­ctor Aguilera Puerto <6766154+Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 2020 ike709 <ike709@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 20kdc <asdd2808@gmail.com>
// SPDX-FileCopyrightText: 2021 Acruid <shatter66@gmail.com>
// SPDX-FileCopyrightText: 2021 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Galactic Chimp <63882831+GalacticChimp@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 2021 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Ygg01 <y.laughing.man.y@gmail.com>
// SPDX-FileCopyrightText: 2021 mirrorcult <notzombiedude@gmail.com>
// SPDX-FileCopyrightText: 2022 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2022 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 2022 Paul Ritter <ritter.paul1@googlemail.com>
// SPDX-FileCopyrightText: 2022 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 AWF <you@example.com>
// SPDX-FileCopyrightText: 2024 Brandon Li <48413902+aspiringLich@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 GitHubUser53123 <110841413+GitHubUser53123@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Guillaume E <262623+quatre@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kevin Zheng <kevinz5000@gmail.com>
// SPDX-FileCopyrightText: 2024 Kira Bridgeton <161087999+Verbalase@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 IrisTheAmped <iristheamped@gmail.com>
// SPDX-FileCopyrightText: 2025 SX-7 <sn1.test.preria.2002@gmail.com>
// SPDX-FileCopyrightText: 2025 SolsticeOfTheWinter <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 pathetic meowmeow <uhhadd@gmail.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Linq;
using Content.Client.Stylesheets;
using Content.Client.UserInterface.Controls;
using Content.Goobstation.Shared.Chemistry;
using Content.Shared.Chemistry;
using Content.Shared.Chemistry.Reagent;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using static Robust.Client.UserInterface.Controls.BoxContainer;

namespace Content.Goobstation.Client.Chemistry.UI
{
    [GenerateTypedNameReferences]
    public sealed partial class EnergyReagentDispenserWindow : FancyWindow
    {
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly IEntityManager _entityManager = default!;

        private float _batteryCharge;
        private float _batteryMaxCharge;
        private float _currentReceiving;
        private float _idleUse;
        private bool _usingBattery;
        private bool _hasPower;
        private int _selectedAmount;
        private float _lastBatteryCharge = -1;
        private bool _cardsNeedUpdate = true;
        public event Action<string>? OnDispenseReagentButtonPressed;
        public EnergyReagentDispenserWindow()
        {
            RobustXamlLoader.Load(this);
            IoCManager.InjectDependencies(this);
        }
        public void UpdateReagentsList(List<EnergyReagentInventoryItem> inventory)
        {
            if (ReagentList == null)
                return;

            ReagentList.Children.Clear();
            inventory.Sort((x, y) => string.Compare(x.ReagentLabel, y.ReagentLabel, StringComparison.Ordinal));

            foreach (var card in inventory
                         .Select(item => new EnergyReagentCardControl(item)))
            {
                card.OnPressed += OnDispenseReagentButtonPressed;
                ReagentList.Children.Add(card);
            }
            _cardsNeedUpdate = true;
            UpdateCardStates();
        }

        public void UpdateState(BoundUserInterfaceState message)
        {
            if (message is not EnergyReagentDispenserBoundUserInterfaceState state)
                return;

            _batteryMaxCharge = state.BatteryMaxCharge;
            _batteryCharge = state.BatteryCharge;
            _currentReceiving = state.CurrentReceivingEnergy;
            _idleUse = state.IdleUse;
            _selectedAmount = (int) state.SelectedDispenseAmount;
            _usingBattery = state.UsingBattery;
            _hasPower = state.HasPower;

            UpdateContainerInfo(state);
            UpdateReagentsList(state.Inventory);
            UpdateBatteryPercent();

            _entityManager.TryGetEntity(state.OutputContainerEntity, out var outputContainerEnt);
            View.SetEntity(outputContainerEnt);

            ClearButton.Disabled = state.OutputContainer is null;
            EjectButton.Disabled = state.OutputContainer is null;

            AmountGrid.Selected = ((int) state.SelectedDispenseAmount).ToString();
            _cardsNeedUpdate = true;
            UpdateCardStates();
        }

        private void UpdateBatteryPercent()
        {
            var batteryPercent = _batteryMaxCharge > 0
                ? _batteryCharge / _batteryMaxCharge * 100
                : 0;

            BatteryStatusLabel.Text = $"{_batteryCharge,3:F0}/{_batteryMaxCharge,3:F0} ({batteryPercent,3:F0}%)";
            BatteryStatusLabel.StyleClasses.Clear();
            BatteryStatusLabel.StyleClasses.Add(batteryPercent switch
            {
                > 60 => "Good",
                > 30 => "Caution",
                _ => "Danger",
            });
        }

        private void UpdateContainerInfo(EnergyReagentDispenserBoundUserInterfaceState state)
        {
            ContainerInfo.Children.Clear();

            if (state.OutputContainer is null)
            {
                ContainerInfoName.Text = "";
                ContainerInfoFill.Text = "";
                ContainerInfo.Children.Add(new Label { Text = Loc.GetString("reagent-dispenser-window-no-container-loaded-text") });
                return;
            }

            ContainerInfoName.Text = state.OutputContainer.DisplayName;
            ContainerInfoFill.Text = state.OutputContainer.CurrentVolume + "/" + state.OutputContainer.MaxVolume;

            foreach (var (reagent, quantity) in state.OutputContainer.Reagents!)
            {
                var localizedName = _prototypeManager.TryIndex(reagent.Prototype, out ReagentPrototype? proto)
                    ? proto.LocalizedName
                    : Loc.GetString("reagent-dispenser-window-reagent-name-not-found-text");

                var nameLabel = new Label { Text = $"{localizedName}: " };
                var quantityLabel = new Label
                {
                    Text = Loc.GetString("reagent-dispenser-window-quantity-label-text", ("quantity", quantity)),
                    StyleClasses = { StyleNano.StyleClassLabelSecondaryColor },
                };

                ContainerInfo.Children.Add(new BoxContainer
                {
                    Orientation = LayoutOrientation.Horizontal,
                    Children =
                    {
                        nameLabel,
                        quantityLabel,
                    },
                });
            }
        }

        private void UpdateCardStates()
        {
            if (ReagentList == null || !_cardsNeedUpdate)
                return;

            var stateChanged = false;
            foreach (var child in ReagentList.Children)
            {
                if (child is not EnergyReagentCardControl card)
                    continue;

                var totalCost = card.PowerCostPerUnit * _selectedAmount;
                var shouldBeDisabled = totalCost > _batteryCharge;
                if (card.IsDisabled == shouldBeDisabled)
                    continue;
                stateChanged = true;
                break;
            }

            if (!stateChanged && _lastBatteryCharge == _batteryCharge)
                return;

            _lastBatteryCharge = _batteryCharge;
            _cardsNeedUpdate = false;
            HandleToggle();
        }

        private void HandleToggle()
        {
            foreach (var child in ReagentList.Children)
            {
                if (child is not EnergyReagentCardControl card)
                    continue;

                var totalCost = card.PowerCostPerUnit * _selectedAmount;
                card.SetDisabled(totalCost > _batteryCharge, "Insufficient energy");
            }
        }

        protected override void FrameUpdate(FrameEventArgs args)
        {
            base.FrameUpdate(args);

            var oldCharge = _batteryCharge;

            /// Causes the UI to assume the battery is charging if it is connected to APC, and thus not refresh every tick
            /// Refreshing every tick makes the UI extremely hard to use as buttons cannot be pressed at the same time
            /// We check if ApcPowerReceiverBatteryComponent is enabled, aka the machine is using the battery for idle power as APC is off/disconnected
            /// If you touch this expect the indicator to go fucking whack or the UI to become problematic. UI suck moment. This seriously caused issues for so long because braindead
            /// We add a check for if Powered is false because when the battery hits 0, usingBattery becomes false despite no APC power still, otherwise it will start to tick back up the second it hits 0
            if (_usingBattery || !_hasPower)
                _batteryCharge = Math.Clamp(_batteryCharge - _idleUse * args.DeltaSeconds, 0, _batteryMaxCharge);
            else
                _batteryCharge = Math.Clamp(_batteryCharge + _currentReceiving * args.DeltaSeconds, 0, _batteryMaxCharge);

            if ((int) oldCharge != (int) _batteryCharge)
                UpdateBatteryPercent();

            CheckEnergyThresholds(oldCharge, _batteryCharge);
        }

        private void CheckEnergyThresholds(float oldEnergy, float newEnergy)
        {
            if (ReagentList == null)
                return;

            foreach (var child in ReagentList.Children)
            {
                if (child is not EnergyReagentCardControl card)
                    continue;

                var threshold = card.PowerCostPerUnit * _selectedAmount;
                if ((!(oldEnergy < threshold) || !(newEnergy >= threshold)) &&
                    (!(oldEnergy >= threshold) || !(newEnergy < threshold)))
                    continue;
                _cardsNeedUpdate = true;
                break;
            }
            UpdateCardStates();
        }
    }
}
