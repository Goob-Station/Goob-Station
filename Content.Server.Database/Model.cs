// SPDX-FileCopyrightText: 2020 20kdc <asdd2808@gmail.com>
// SPDX-FileCopyrightText: 2020 DamianX <DamianX@users.noreply.github.com>
// SPDX-FileCopyrightText: 2020 ike709 <ike709@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Leo <lzimann@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Swept <sweptwastaken@protonmail.com>
// SPDX-FileCopyrightText: 2022 Flipp Syder <76629141+vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Javier Guardia Fernández <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Julian Giebel <j.giebel@netrocks.info>
// SPDX-FileCopyrightText: 2022 Moony <moonheart08@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Vera Aguilera Puerto <6766154+Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Veritius <veritiusgaming@gmail.com>
// SPDX-FileCopyrightText: 2022 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Riggle <27156122+RigglePrime@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 12rabbits <53499656+12rabbits@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 AJCM <AJCM@tutanota.com>
// SPDX-FileCopyrightText: 2024 AJCM-git <60196617+AJCM-git@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 2024 Alex Pavlenko <diraven@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Alice "Arimah" Heurlin <30327355+arimah@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Alzore <140123969+Blackern5000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ArkiveDev <95712736+ArkiveDev@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ArtisticRoomba <145879011+ArtisticRoomba@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Boaz1111 <149967078+Boaz1111@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Brandon Hu <103440971+Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Dimastra <65184747+Dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Dimastra <dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Doomsdrayk <robotdoughnut@comcast.net>
// SPDX-FileCopyrightText: 2024 DrEnzyme <DrEnzyme@gmail.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Elysium206 <151651971+Elysium206@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Firewatch <54725557+musicmanvr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Floofi <126319569+Shadowtheprotogen546@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ghagliiarghii <68826635+Ghagliiarghii@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 HS <81934438+HolySSSS@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Hannah Giovanna Dawson <karakkaraz@gmail.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JIPDawg <51352440+JIPDawg@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JIPDawg <JIPDawg93@gmail.com>
// SPDX-FileCopyrightText: 2024 Julian Giebel <juliangiebel@live.de>
// SPDX-FileCopyrightText: 2024 K-Dynamic <20566341+K-Dynamic@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kevin Zheng <kevinz5000@gmail.com>
// SPDX-FileCopyrightText: 2024 Ko4ergaPunk <62609550+Ko4ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Krunklehorn <42424291+Krunklehorn@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 MetalSage <74924875+MetalSage@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MetalSage <metalsage.official@gmail.com>
// SPDX-FileCopyrightText: 2024 MilenVolf <63782763+MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Moomoobeef <62638182+Moomoobeef@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <koolthunder019@gmail.com>
// SPDX-FileCopyrightText: 2024 MureixloI <132683811+MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Partmedia <kevinz5000@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PoTeletubby <151896601+PoTeletubby@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PopGamer46 <yt1popgamer@gmail.com>
// SPDX-FileCopyrightText: 2024 PursuitInAshes <pursuitinashes@gmail.com>
// SPDX-FileCopyrightText: 2024 QueerNB <176353696+QueerNB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Redfire1331 <125223432+Redfire1331@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Rouge2t7 <81053047+Sarahon@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 2024 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Simon <63975668+Simyon264@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Spessmann <156740760+Spessmann@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Truoizys <153248924+Truoizys@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 WarMechanic <69510347+WarMechanic@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Winkarst <74284083+Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deathride58 <deathride58@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 marbow <152051971+marboww@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 mhamster <81412348+mhamsterr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 neutrino <67447925+neutrino-laser@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 osjarw <62134478+osjarw@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 redfire1331 <Redfire1331@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 stellar-novas <stellar_novas@riseup.net>
// SPDX-FileCopyrightText: 2024 themias <89101928+themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Арт <123451459+JustArt1m@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <93730715+Aviu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 Ichaie <167008606+Ichaie@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 JORJ949 <159719201+JORJ949@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 MortalBaguette <169563638+MortalBaguette@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Myra <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2025 PJB3005 <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2025 Panela <107573283+AgentePanela@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2025 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2025 Poips <Hanakohashbrown@gmail.com>
// SPDX-FileCopyrightText: 2025 PuroSlavKing <103608145+PuroSlavKing@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Solstice <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 Whisper <121047731+QuietlyWhisper@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 blobadoodle <me@bloba.dev>
// SPDX-FileCopyrightText: 2025 coderabbitai[bot] <136622811+coderabbitai[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2025 github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 kamkoi <poiiiple1@gmail.com>
// SPDX-FileCopyrightText: 2025 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 nikthechampiongr <32041239+nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 shibe <95730644+shibechef@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 tetra <169831122+Foralemes@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Net;
using System.Text.Json;
using Content.Shared.Database;
using Microsoft.EntityFrameworkCore;
using NpgsqlTypes;

namespace Content.Server.Database
{
    public abstract class ServerDbContext : DbContext
    {
        protected ServerDbContext(DbContextOptions options) : base(options)
        {
        }

        public DbSet<Preference> Preference { get; set; } = null!;
        public DbSet<Profile> Profile { get; set; } = null!;
        public DbSet<AssignedUserId> AssignedUserId { get; set; } = null!;
        public DbSet<Player> Player { get; set; } = default!;
        public DbSet<Admin> Admin { get; set; } = null!;
        public DbSet<AdminRank> AdminRank { get; set; } = null!;
        public DbSet<Round> Round { get; set; } = null!;
        public DbSet<Server> Server { get; set; } = null!;
        public DbSet<AdminLog> AdminLog { get; set; } = null!;
        public DbSet<AdminLogPlayer> AdminLogPlayer { get; set; } = null!;
        public DbSet<Whitelist> Whitelist { get; set; } = null!;
        public DbSet<Blacklist> Blacklist { get; set; } = null!;
        public DbSet<ServerBan> Ban { get; set; } = default!;
        public DbSet<ServerUnban> Unban { get; set; } = default!;
        public DbSet<ServerBanExemption> BanExemption { get; set; } = default!;
        public DbSet<ConnectionLog> ConnectionLog { get; set; } = default!;
        public DbSet<ServerBanHit> ServerBanHit { get; set; } = default!;
        public DbSet<ServerRoleBan> RoleBan { get; set; } = default!;
        public DbSet<ServerRoleUnban> RoleUnban { get; set; } = default!;
        public DbSet<PlayTime> PlayTime { get; set; } = default!;
        public DbSet<UploadedResourceLog> UploadedResourceLog { get; set; } = default!;
        public DbSet<AdminNote> AdminNotes { get; set; } = null!;
        public DbSet<AdminWatchlist> AdminWatchlists { get; set; } = null!;
        public DbSet<AdminMessage> AdminMessages { get; set; } = null!;
        public DbSet<RoleWhitelist> RoleWhitelists { get; set; } = null!;
        public DbSet<BanTemplate> BanTemplate { get; set; } = null!;
        public DbSet<IPIntelCache> IPIntelCache { get; set; } = null!;

        // RMC14
        public DbSet<RMCDiscordAccount> RMCDiscordAccounts { get; set; } = default!;
        public DbSet<RMCLinkedAccount> RMCLinkedAccounts { get; set; } = default!;
        public DbSet<RMCPatronTier> RMCPatronTiers { get; set; } = default!;
        public DbSet<RMCPatron> RMCPatrons { get; set; } = default!;
        public DbSet<RMCLinkingCodes> RMCLinkingCodes { get; set; } = default!;
        public DbSet<RMCLinkedAccountLogs> RMCLinkedAccountLogs { get; set; } = default!;
        public DbSet<RMCPatronLobbyMessage> RMCPatronLobbyMessages { get; set; } = default!;
        public DbSet<RMCPatronRoundEndNTShoutout> RMCPatronRoundEndNTShoutouts { get; set; } = default!;

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<Preference>()
                .HasIndex(p => p.UserId)
                .IsUnique();

            modelBuilder.Entity<Profile>()
                .HasIndex(p => new { p.Slot, PrefsId = p.PreferenceId })
                .IsUnique();

            modelBuilder.Entity<Antag>()
                .HasIndex(p => new { HumanoidProfileId = p.ProfileId, p.AntagName })
                .IsUnique();

            modelBuilder.Entity<Trait>()
                .HasIndex(p => new { HumanoidProfileId = p.ProfileId, p.TraitName })
                .IsUnique();

            modelBuilder.Entity<ProfileRoleLoadout>()
                .HasOne(e => e.Profile)
                .WithMany(e => e.Loadouts)
                .HasForeignKey(e => e.ProfileId)
                .IsRequired();

            modelBuilder.Entity<ProfileLoadoutGroup>()
                .HasOne(e => e.ProfileRoleLoadout)
                .WithMany(e => e.Groups)
                .HasForeignKey(e => e.ProfileRoleLoadoutId)
                .IsRequired();

            modelBuilder.Entity<ProfileLoadout>()
                .HasOne(e => e.ProfileLoadoutGroup)
                .WithMany(e => e.Loadouts)
                .HasForeignKey(e => e.ProfileLoadoutGroupId)
                .IsRequired();

            modelBuilder.Entity<Job>()
                .HasIndex(j => j.ProfileId);

            modelBuilder.Entity<Job>()
                .HasIndex(j => j.ProfileId, "IX_job_one_high_priority")
                .IsUnique()
                .HasFilter("priority = 3");

            modelBuilder.Entity<Job>()
                .HasIndex(j => new { j.ProfileId, j.JobName })
                .IsUnique();

            modelBuilder.Entity<AssignedUserId>()
                .HasIndex(p => p.UserName)
                .IsUnique();

            // Can't have two usernames with the same user ID.
            modelBuilder.Entity<AssignedUserId>()
                .HasIndex(p => p.UserId)
                .IsUnique();

            modelBuilder.Entity<Admin>()
                .HasOne(p => p.AdminRank)
                .WithMany(p => p!.Admins)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminFlag>()
                .HasIndex(f => new { f.Flag, f.AdminId })
                .IsUnique();

            modelBuilder.Entity<AdminRankFlag>()
                .HasIndex(f => new { f.Flag, f.AdminRankId })
                .IsUnique();

            modelBuilder.Entity<AdminLog>()
                .HasKey(log => new { log.RoundId, log.Id });

            modelBuilder.Entity<AdminLog>()
                .Property(log => log.Id);

            modelBuilder.Entity<AdminLog>()
                .HasIndex(log => log.Date);

            modelBuilder.Entity<PlayTime>()
                .HasIndex(v => new { v.PlayerId, Role = v.Tracker })
                .IsUnique();

            modelBuilder.Entity<AdminLogPlayer>()
                .HasOne(player => player.Player)
                .WithMany(player => player.AdminLogs)
                .HasForeignKey(player => player.PlayerUserId)
                .HasPrincipalKey(player => player.UserId);

            modelBuilder.Entity<AdminLogPlayer>()
                .HasIndex(p => p.PlayerUserId);

            modelBuilder.Entity<Round>()
                .HasIndex(round => round.StartDate);

            modelBuilder.Entity<AdminLogPlayer>()
                .HasKey(logPlayer => new { logPlayer.RoundId, logPlayer.LogId, logPlayer.PlayerUserId });

            modelBuilder.Entity<ServerBan>()
                .HasIndex(p => p.PlayerUserId);

            modelBuilder.Entity<ServerBan>()
                .HasIndex(p => p.Address);

            modelBuilder.Entity<ServerBan>()
                .HasIndex(p => p.PlayerUserId);

            modelBuilder.Entity<ServerUnban>()
                .HasIndex(p => p.BanId)
                .IsUnique();

            modelBuilder.Entity<ServerBan>().ToTable(t =>
                t.HasCheckConstraint("HaveEitherAddressOrUserIdOrHWId", "address IS NOT NULL OR player_user_id IS NOT NULL OR hwid IS NOT NULL"));

            // Ban exemption can't have flags 0 since that wouldn't exempt anything.
            // The row should be removed if setting to 0.
            modelBuilder.Entity<ServerBanExemption>().ToTable(t =>
                t.HasCheckConstraint("FlagsNotZero", "flags != 0"));

            modelBuilder.Entity<ServerRoleBan>()
                .HasIndex(p => p.PlayerUserId);

            modelBuilder.Entity<ServerRoleBan>()
                .HasIndex(p => p.Address);

            modelBuilder.Entity<ServerRoleBan>()
                .HasIndex(p => p.PlayerUserId);

            modelBuilder.Entity<ServerRoleUnban>()
                .HasIndex(p => p.BanId)
                .IsUnique();

            modelBuilder.Entity<ServerRoleBan>().ToTable(t =>
                t.HasCheckConstraint("HaveEitherAddressOrUserIdOrHWId", "address IS NOT NULL OR player_user_id IS NOT NULL OR hwid IS NOT NULL"));

            modelBuilder.Entity<Player>()
                .HasIndex(p => p.UserId)
                .IsUnique();

            modelBuilder.Entity<Player>()
                .HasIndex(p => p.LastSeenUserName);

            modelBuilder.Entity<ConnectionLog>()
                .HasIndex(p => p.UserId);

            modelBuilder.Entity<ConnectionLog>()
                .HasIndex(p => p.Time);

            modelBuilder.Entity<ConnectionLog>()
                .Property(p => p.ServerId)
                .HasDefaultValue(0);

            modelBuilder.Entity<ConnectionLog>()
                .HasOne(p => p.Server)
                .WithMany(p => p.ConnectionLogs)
                .OnDelete(DeleteBehavior.SetNull);

            // SetNull is necessary for created by/edited by-s here,
            // so you can safely delete admins (GDPR right to erasure) while keeping the notes intact

            modelBuilder.Entity<AdminNote>()
                .HasOne(note => note.Player)
                .WithMany(player => player.AdminNotesReceived)
                .HasForeignKey(note => note.PlayerUserId)
                .HasPrincipalKey(player => player.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<AdminNote>()
                .HasOne(version => version.CreatedBy)
                .WithMany(author => author.AdminNotesCreated)
                .HasForeignKey(note => note.CreatedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminNote>()
                .HasOne(version => version.LastEditedBy)
                .WithMany(author => author.AdminNotesLastEdited)
                .HasForeignKey(note => note.LastEditedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminNote>()
                .HasOne(version => version.DeletedBy)
                .WithMany(author => author.AdminNotesDeleted)
                .HasForeignKey(note => note.DeletedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminWatchlist>()
                .HasOne(note => note.Player)
                .WithMany(player => player.AdminWatchlistsReceived)
                .HasForeignKey(note => note.PlayerUserId)
                .HasPrincipalKey(player => player.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<AdminWatchlist>()
                .HasOne(version => version.CreatedBy)
                .WithMany(author => author.AdminWatchlistsCreated)
                .HasForeignKey(note => note.CreatedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminWatchlist>()
                .HasOne(version => version.LastEditedBy)
                .WithMany(author => author.AdminWatchlistsLastEdited)
                .HasForeignKey(note => note.LastEditedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminWatchlist>()
                .HasOne(version => version.DeletedBy)
                .WithMany(author => author.AdminWatchlistsDeleted)
                .HasForeignKey(note => note.DeletedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminMessage>()
                .HasOne(note => note.Player)
                .WithMany(player => player.AdminMessagesReceived)
                .HasForeignKey(note => note.PlayerUserId)
                .HasPrincipalKey(player => player.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<AdminMessage>()
                .HasOne(version => version.CreatedBy)
                .WithMany(author => author.AdminMessagesCreated)
                .HasForeignKey(note => note.CreatedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminMessage>()
                .HasOne(version => version.LastEditedBy)
                .WithMany(author => author.AdminMessagesLastEdited)
                .HasForeignKey(note => note.LastEditedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<AdminMessage>()
                .HasOne(version => version.DeletedBy)
                .WithMany(author => author.AdminMessagesDeleted)
                .HasForeignKey(note => note.DeletedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            // A message cannot be "dismissed" without also being "seen".
            modelBuilder.Entity<AdminMessage>().ToTable(t =>
                t.HasCheckConstraint("NotDismissedAndSeen",
                    "NOT dismissed OR seen"));

            modelBuilder.Entity<ServerBan>()
                .HasOne(ban => ban.CreatedBy)
                .WithMany(author => author.AdminServerBansCreated)
                .HasForeignKey(ban => ban.BanningAdmin)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<ServerBan>()
                .HasOne(ban => ban.LastEditedBy)
                .WithMany(author => author.AdminServerBansLastEdited)
                .HasForeignKey(ban => ban.LastEditedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<ServerRoleBan>()
                .HasOne(ban => ban.CreatedBy)
                .WithMany(author => author.AdminServerRoleBansCreated)
                .HasForeignKey(ban => ban.BanningAdmin)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<ServerRoleBan>()
                .HasOne(ban => ban.LastEditedBy)
                .WithMany(author => author.AdminServerRoleBansLastEdited)
                .HasForeignKey(ban => ban.LastEditedById)
                .HasPrincipalKey(author => author.UserId)
                .OnDelete(DeleteBehavior.SetNull);

            modelBuilder.Entity<RoleWhitelist>()
                .HasOne(w => w.Player)
                .WithMany(p => p.JobWhitelists)
                .HasForeignKey(w => w.PlayerUserId)
                .HasPrincipalKey(p => p.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            // Changes for modern HWID integration
            modelBuilder.Entity<Player>()
                .OwnsOne(p => p.LastSeenHWId)
                .Property(p => p.Hwid)
                .HasColumnName("last_seen_hwid");

            modelBuilder.Entity<Player>()
                .OwnsOne(p => p.LastSeenHWId)
                .Property(p => p.Type)
                .HasDefaultValue(HwidType.Legacy);

            modelBuilder.Entity<ServerBan>()
                .OwnsOne(p => p.HWId)
                .Property(p => p.Hwid)
                .HasColumnName("hwid");

            modelBuilder.Entity<ServerBan>()
                .OwnsOne(p => p.HWId)
                .Property(p => p.Type)
                .HasDefaultValue(HwidType.Legacy);

            modelBuilder.Entity<ServerRoleBan>()
                .OwnsOne(p => p.HWId)
                .Property(p => p.Hwid)
                .HasColumnName("hwid");

            modelBuilder.Entity<ServerRoleBan>()
                .OwnsOne(p => p.HWId)
                .Property(p => p.Type)
                .HasDefaultValue(HwidType.Legacy);

            modelBuilder.Entity<ConnectionLog>()
                .OwnsOne(p => p.HWId)
                .Property(p => p.Hwid)
                .HasColumnName("hwid");

            modelBuilder.Entity<ConnectionLog>()
                .OwnsOne(p => p.HWId)
                .Property(p => p.Type)
                .HasDefaultValue(HwidType.Legacy);

            // RMC14
            modelBuilder.Entity<RMCLinkedAccount>()
                .HasOne(l => l.Player)
                .WithOne(p => p.LinkedAccount)
                .HasForeignKey<RMCLinkedAccount>(l => l.PlayerId)
                .HasPrincipalKey<Player>(p => p.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RMCLinkedAccount>()
                .HasOne(l => l.Discord)
                .WithOne(d => d.LinkedAccount)
                .HasForeignKey<RMCLinkedAccount>(l => l.DiscordId)
                .HasPrincipalKey<RMCDiscordAccount>(d => d.Id)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RMCPatron>()
                .HasOne(p => p.Player)
                .WithOne(p => p.Patron)
                .HasForeignKey<RMCPatron>(p => p.PlayerId)
                .HasPrincipalKey<Player>(p => p.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RMCPatron>()
                .HasOne(p => p.Tier)
                .WithMany(t => t.Patrons)
                .HasForeignKey(p => p.TierId)
                .HasPrincipalKey(p => p.Id)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RMCPatronTier>()
                .HasIndex(t => t.DiscordRole)
                .IsUnique();

            modelBuilder.Entity<RMCLinkingCodes>()
                .HasOne(l => l.Player)
                .WithOne(p => p.LinkingCodes)
                .HasForeignKey<RMCLinkingCodes>(l => l.PlayerId)
                .HasPrincipalKey<Player>(p => p.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RMCLinkedAccountLogs>()
                .HasOne(l => l.Player)
                .WithMany(p => p.LinkedAccountLogs)
                .HasForeignKey(l => l.PlayerId)
                .HasPrincipalKey(p => p.UserId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RMCLinkedAccountLogs>()
                .HasOne(l => l.Discord)
                .WithMany(p => p.LinkedAccountLogs)
                .HasForeignKey(l => l.DiscordId)
                .HasPrincipalKey(p => p.Id)
                .OnDelete(DeleteBehavior.Cascade);
        }

        public virtual IQueryable<AdminLog> SearchLogs(IQueryable<AdminLog> query, string searchText)
        {
            return query.Where(log => EF.Functions.Like(log.Message, "%" + searchText + "%"));
        }

        public abstract int CountAdminLogs();
    }

    public class Preference
    {
        // NOTE: on postgres there SHOULD be an FK ensuring that the selected character slot always exists.
        // I had to use a migration to implement it and as a result its creation is a finicky mess.
        // Because if I let EFCore know about it it would explode on a circular reference.
        // Also it has to be DEFERRABLE INITIALLY DEFERRED so that insertion of new preferences works.
        // Also I couldn't figure out how to create it on SQLite.
        public int Id { get; set; }
        public Guid UserId { get; set; }
        public int SelectedCharacterSlot { get; set; }
        public string AdminOOCColor { get; set; } = null!;
        public List<Profile> Profiles { get; } = new();
    }

    public class Profile
    {
        public int Id { get; set; }
        public int Slot { get; set; }
        [Column("char_name")] public string CharacterName { get; set; } = null!;
        public string FlavorText { get; set; } = null!;
        // #Goobstation - Borg Preferred Name
        public string BorgName { get; set; } = null!;
        public int Age { get; set; }
        public string Sex { get; set; } = null!;
        public string Gender { get; set; } = null!;
        public string Species { get; set; } = null!;
        [Column(TypeName = "jsonb")] public JsonDocument? Markings { get; set; } = null!;
        public string HairName { get; set; } = null!;
        public string HairColor { get; set; } = null!;
        public string FacialHairName { get; set; } = null!;
        public string FacialHairColor { get; set; } = null!;
        public string EyeColor { get; set; } = null!;
        public string SkinColor { get; set; } = null!;
        public int SpawnPriority { get; set; } = 0;
        public List<Job> Jobs { get; } = new();
        public List<Antag> Antags { get; } = new();
        public List<Trait> Traits { get; } = new();

        public List<ProfileRoleLoadout> Loadouts { get; } = new();

        [Column("pref_unavailable")] public DbPreferenceUnavailableMode PreferenceUnavailable { get; set; }

        public int PreferenceId { get; set; }
        public Preference Preference { get; set; } = null!;
    }

    public class Job
    {
        public int Id { get; set; }
        public Profile Profile { get; set; } = null!;
        public int ProfileId { get; set; }

        public string JobName { get; set; } = null!;
        public DbJobPriority Priority { get; set; }
    }

    public enum DbJobPriority
    {
        // These enum values HAVE to match the ones in JobPriority in Content.Shared
        Never = 0,
        Low = 1,
        Medium = 2,
        High = 3
    }

    public class Antag
    {
        public int Id { get; set; }
        public Profile Profile { get; set; } = null!;
        public int ProfileId { get; set; }

        public string AntagName { get; set; } = null!;
    }

    public class Trait
    {
        public int Id { get; set; }
        public Profile Profile { get; set; } = null!;
        public int ProfileId { get; set; }

        public string TraitName { get; set; } = null!;
    }

    #region Loadouts

    /// <summary>
    /// Corresponds to a single role's loadout inside the DB.
    /// </summary>
    public class ProfileRoleLoadout
    {
        public int Id { get; set; }

        public int ProfileId { get; set; }

        public Profile Profile { get; set; } = null!;

        /// <summary>
        /// The corresponding role prototype on the profile.
        /// </summary>
        public string RoleName { get; set; } = string.Empty;

        /// <summary>
        /// Custom name of the role loadout if it supports it.
        /// </summary>
        [MaxLength(256)]
        public string? EntityName { get; set; }

        /// <summary>
        /// Store the saved loadout groups. These may get validated and removed when loaded at runtime.
        /// </summary>
        public List<ProfileLoadoutGroup> Groups { get; set; } = new();
    }

    /// <summary>
    /// Corresponds to a loadout group prototype with the specified loadouts attached.
    /// </summary>
    public class ProfileLoadoutGroup
    {
        public int Id { get; set; }

        public int ProfileRoleLoadoutId { get; set; }

        /// <summary>
        /// The corresponding RoleLoadout that owns this.
        /// </summary>
        public ProfileRoleLoadout ProfileRoleLoadout { get; set; } = null!;

        /// <summary>
        /// The corresponding group prototype.
        /// </summary>
        public string GroupName { get; set; } = string.Empty;

        /// <summary>
        /// Selected loadout prototype. Null if none is set.
        /// May get validated at runtime and updated to to the default.
        /// </summary>
        public List<ProfileLoadout> Loadouts { get; set; } = new();
    }

    /// <summary>
    /// Corresponds to a selected loadout.
    /// </summary>
    public class ProfileLoadout
    {
        public int Id { get; set; }

        public int ProfileLoadoutGroupId { get; set; }

        public ProfileLoadoutGroup ProfileLoadoutGroup { get; set; } = null!;

        /// <summary>
        /// Corresponding loadout prototype.
        /// </summary>
        public string LoadoutName { get; set; } = string.Empty;

        /*
         * Insert extra data here like custom descriptions or colors or whatever.
         */
    }

    #endregion

    public enum DbPreferenceUnavailableMode
    {
        // These enum values HAVE to match the ones in PreferenceUnavailableMode in Shared.
        StayInLobby = 0,
        SpawnAsOverflow,
    }

    public class AssignedUserId
    {
        public int Id { get; set; }
        public string UserName { get; set; } = null!;

        public Guid UserId { get; set; }
    }

    [Table("player")]
    public class Player
    {
        public int Id { get; set; }

        // Permanent data
        public Guid UserId { get; set; }
        public DateTime FirstSeenTime { get; set; }

        // Data that gets updated on each join.
        public string LastSeenUserName { get; set; } = null!;
        public DateTime LastSeenTime { get; set; }
        public IPAddress LastSeenAddress { get; set; } = null!;
        public TypedHwid? LastSeenHWId { get; set; }

        // Data that changes with each round
        public List<Round> Rounds { get; set; } = null!;
        public List<AdminLogPlayer> AdminLogs { get; set; } = null!;

        public int ServerCurrency { get; set; } // Goobstation - Goob coin

        public DateTime? LastReadRules { get; set; }

        public List<AdminNote> AdminNotesReceived { get; set; } = null!;
        public List<AdminNote> AdminNotesCreated { get; set; } = null!;
        public List<AdminNote> AdminNotesLastEdited { get; set; } = null!;
        public List<AdminNote> AdminNotesDeleted { get; set; } = null!;
        public List<AdminWatchlist> AdminWatchlistsReceived { get; set; } = null!;
        public List<AdminWatchlist> AdminWatchlistsCreated { get; set; } = null!;
        public List<AdminWatchlist> AdminWatchlistsLastEdited { get; set; } = null!;
        public List<AdminWatchlist> AdminWatchlistsDeleted { get; set; } = null!;
        public List<AdminMessage> AdminMessagesReceived { get; set; } = null!;
        public List<AdminMessage> AdminMessagesCreated { get; set; } = null!;
        public List<AdminMessage> AdminMessagesLastEdited { get; set; } = null!;
        public List<AdminMessage> AdminMessagesDeleted { get; set; } = null!;
        public List<ServerBan> AdminServerBansCreated { get; set; } = null!;
        public List<ServerBan> AdminServerBansLastEdited { get; set; } = null!;
        public List<ServerRoleBan> AdminServerRoleBansCreated { get; set; } = null!;
        public List<ServerRoleBan> AdminServerRoleBansLastEdited { get; set; } = null!;
        public List<RoleWhitelist> JobWhitelists { get; set; } = null!;

        // RMC14
        public RMCLinkedAccount? LinkedAccount { get; set; }
        public RMCPatron? Patron { get; set; }
        public RMCLinkingCodes? LinkingCodes { get; set; }
        public List<RMCLinkedAccountLogs> LinkedAccountLogs { get; set; } = default!;
    }

    [Table("whitelist")]
    public class Whitelist
    {
        [Required, Key] public Guid UserId { get; set; }
    }

    /// <summary>
    /// List of users who are on the "blacklist". This is a list that may be used by Whitelist implementations to deny access to certain users.
    /// </summary>
    [Table("blacklist")]
    public class Blacklist
    {
        [Required, Key] public Guid UserId { get; set; }
    }

    public class Admin
    {
        [Key] public Guid UserId { get; set; }
        public string? Title { get; set; }

        /// <summary>
        /// If true, the admin is voluntarily deadminned. They can re-admin at any time.
        /// </summary>
        public bool Deadminned { get; set; }

        /// <summary>
        /// If true, the admin is suspended by an admin with <c>PERMISSIONS</c>. They will not have in-game permissions.
        /// </summary>
        public bool Suspended { get; set; }

        public int? AdminRankId { get; set; }
        public AdminRank? AdminRank { get; set; }
        public List<AdminFlag> Flags { get; set; } = default!;
    }

    public class AdminFlag
    {
        public int Id { get; set; }
        public string Flag { get; set; } = default!;
        public bool Negative { get; set; }

        public Guid AdminId { get; set; }
        public Admin Admin { get; set; } = default!;
    }

    public class AdminRank
    {
        public int Id { get; set; }
        public string Name { get; set; } = default!;

        public List<Admin> Admins { get; set; } = default!;
        public List<AdminRankFlag> Flags { get; set; } = default!;
    }

    public class AdminRankFlag
    {
        public int Id { get; set; }
        public string Flag { get; set; } = default!;

        public int AdminRankId { get; set; }
        public AdminRank Rank { get; set; } = default!;
    }

    public class Round
    {
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        public DateTime? StartDate { get; set; }

        public List<Player> Players { get; set; } = default!;

        public List<AdminLog> AdminLogs { get; set; } = default!;

        [ForeignKey("Server")] public int ServerId { get; set; }
        public Server Server { get; set; } = default!;
    }

    public class Server
    {
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        public string Name { get; set; } = default!;

        [InverseProperty(nameof(Round.Server))]
        public List<Round> Rounds { get; set; } = default!;

        [InverseProperty(nameof(ConnectionLog.Server))]
        public List<ConnectionLog> ConnectionLogs { get; set; } = default!;
    }

    [Index(nameof(Type))]
    public class AdminLog
    {
        [Key, ForeignKey("Round")] public int RoundId { get; set; }

        [Key]
        public int Id { get; set; }

        public Round Round { get; set; } = default!;

        [Required] public LogType Type { get; set; }

        [Required] public LogImpact Impact { get; set; }

        [Required] public DateTime Date { get; set; }

        [Required] public string Message { get; set; } = default!;

        [Required, Column(TypeName = "jsonb")] public JsonDocument Json { get; set; } = default!;

        public List<AdminLogPlayer> Players { get; set; } = default!;
    }

    public class AdminLogPlayer
    {
        [Required, Key] public int RoundId { get; set; }
        [Required, Key] public int LogId { get; set; }

        [Required, Key, ForeignKey("Player")] public Guid PlayerUserId { get; set; }
        public Player Player { get; set; } = default!;

        [ForeignKey("RoundId,LogId")] public AdminLog Log { get; set; } = default!;
    }

    // Used by SS14.Admin
    public interface IBanCommon<TUnban> where TUnban : IUnbanCommon
    {
        int Id { get; set; }
        Guid? PlayerUserId { get; set; }
        NpgsqlInet? Address { get; set; }
        TypedHwid? HWId { get; set; }
        DateTime BanTime { get; set; }
        DateTime? ExpirationTime { get; set; }
        string Reason { get; set; }
        NoteSeverity Severity { get; set; }
        Guid? BanningAdmin { get; set; }
        TUnban? Unban { get; set; }
    }

    // Used by SS14.Admin
    public interface IUnbanCommon
    {
        int Id { get; set; }
        int BanId { get; set; }
        Guid? UnbanningAdmin { get; set; }
        DateTime UnbanTime { get; set; }
    }

    /// <summary>
    /// Flags for use with <see cref="ServerBanExemption"/>.
    /// </summary>
    [Flags]
    public enum ServerBanExemptFlags
    {
        // @formatter:off
        None = 0,

        /// <summary>
        /// Ban is a datacenter range, connections usually imply usage of a VPN service.
        /// </summary>
        Datacenter = 1 << 0,

        /// <summary>
        /// Ban only matches the IP.
        /// </summary>
        /// <remarks>
        /// Intended use is for users with shared connections. This should not be used as an alternative to <see cref="Datacenter"/>.
        /// </remarks>
        IP = 1 << 1,

        /// <summary>
        /// Ban is an IP range that is only applied for first time joins.
        /// </summary>
        /// <remarks>
        /// Intended for use with residential IP ranges that are often used maliciously.
        /// </remarks>
        BlacklistedRange = 1 << 2,

        /// <summary>
        /// Represents having all possible exemption flags.
        /// </summary>
        All = int.MaxValue,
        // @formatter:on
    }

    /// <summary>
    /// A ban from playing on the server.
    /// If an incoming connection matches any of UserID, IP, or HWID, they will be blocked from joining the server.
    /// </summary>
    /// <remarks>
    /// At least one of UserID, IP, or HWID must be given (otherwise the ban would match nothing).
    /// </remarks>
    [Table("server_ban"), Index(nameof(PlayerUserId))]
    public class ServerBan : IBanCommon<ServerUnban>
    {
        public int Id { get; set; }

        [ForeignKey("Round")]
        public int? RoundId { get; set; }
        public Round? Round { get; set; }

        /// <summary>
        /// The user ID of the banned player.
        /// </summary>
        public Guid? PlayerUserId { get; set; }
        [Required] public TimeSpan PlaytimeAtNote { get; set; }

        /// <summary>
        /// CIDR IP address range of the ban. The whole range can match the ban.
        /// </summary>
        public NpgsqlInet? Address { get; set; }

        /// <summary>
        /// Hardware ID of the banned player.
        /// </summary>
        public TypedHwid? HWId { get; set; }

        /// <summary>
        /// The time when the ban was applied by an administrator.
        /// </summary>
        public DateTime BanTime { get; set; }

        /// <summary>
        /// The time the ban will expire. If null, the ban is permanent and will not expire naturally.
        /// </summary>
        public DateTime? ExpirationTime { get; set; }

        /// <summary>
        /// The administrator-stated reason for applying the ban.
        /// </summary>
        public string Reason { get; set; } = null!;

        /// <summary>
        /// The severity of the incident
        /// </summary>
        public NoteSeverity Severity { get; set; }

        /// <summary>
        /// User ID of the admin that applied the ban.
        /// </summary>
        [ForeignKey("CreatedBy")]
        public Guid? BanningAdmin { get; set; }

        public Player? CreatedBy { get; set; }

        /// <summary>
        /// User ID of the admin that last edited the note
        /// </summary>
        [ForeignKey("LastEditedBy")]
        public Guid? LastEditedById { get; set; }

        public Player? LastEditedBy { get; set; }

        /// <summary>
        /// When the ban was last edited
        /// </summary>
        public DateTime? LastEditedAt { get; set; }

        /// <summary>
        /// Optional flags that allow adding exemptions to the ban via <see cref="ServerBanExemption"/>.
        /// </summary>
        public ServerBanExemptFlags ExemptFlags { get; set; }

        /// <summary>
        /// If present, an administrator has manually repealed this ban.
        /// </summary>
        public ServerUnban? Unban { get; set; }

        /// <summary>
        /// Whether this ban should be automatically deleted from the database when it expires.
        /// </summary>
        /// <remarks>
        /// This isn't done automatically by the game,
        /// you will need to set up something like a cron job to clear this from your database,
        /// using a command like this:
        /// psql -d ss14 -c "DELETE FROM server_ban WHERE auto_delete AND expiration_time &lt; NOW()"
        /// </remarks>
        public bool AutoDelete { get; set; }

        /// <summary>
        /// Whether to display this ban in the admin remarks (notes) panel
        /// </summary>
        public bool Hidden { get; set; }

        public List<ServerBanHit> BanHits { get; set; } = null!;
    }

    /// <summary>
    /// An explicit repeal of a <see cref="ServerBan"/> by an administrator.
    /// Having an entry for a ban neutralizes it.
    /// </summary>
    [Table("server_unban")]
    public class ServerUnban : IUnbanCommon
    {
        [Column("unban_id")] public int Id { get; set; }

        /// <summary>
        /// The ID of ban that is being repealed.
        /// </summary>
        public int BanId { get; set; }

        /// <summary>
        /// The ban that is being repealed.
        /// </summary>
        public ServerBan Ban { get; set; } = null!;

        /// <summary>
        /// The admin that repealed the ban.
        /// </summary>
        public Guid? UnbanningAdmin { get; set; }

        /// <summary>
        /// The time the ban repealed.
        /// </summary>
        public DateTime UnbanTime { get; set; }
    }

    /// <summary>
    /// An exemption for a specific user to a certain type of <see cref="ServerBan"/>.
    /// </summary>
    /// <example>
    /// Certain players may need to be exempted from VPN bans due to issues with their ISP.
    /// We would tag all VPN bans with <see cref="ServerBanExemptFlags.Datacenter"/>,
    /// and then add an exemption for these players to this table with the same flag.
    /// They will only be exempted from VPN bans, other bans (if they manage to get any) will still apply.
    /// </example>
    [Table("server_ban_exemption")]
    public sealed class ServerBanExemption
    {
        /// <summary>
        /// The UserID of the exempted player.
        /// </summary>
        [Key]
        public Guid UserId { get; set; }

        /// <summary>
        /// The ban flags to exempt this player from.
        /// If any bit overlaps <see cref="ServerBan.ExemptFlags"/>, the ban is ignored.
        /// </summary>
        public ServerBanExemptFlags Flags { get; set; }
    }

    [Table("connection_log")]
    public class ConnectionLog
    {
        public int Id { get; set; }

        public Guid UserId { get; set; }
        public string UserName { get; set; } = null!;

        public DateTime Time { get; set; }

        public IPAddress Address { get; set; } = null!;
        public TypedHwid? HWId { get; set; }

        public ConnectionDenyReason? Denied { get; set; }

        /// <summary>
        /// ID of the <see cref="Server"/> that the connection was attempted to.
        /// </summary>
        /// <remarks>
        /// <para>
        /// The default value of this column is set to <c>0</c>, which is the ID of the "<c>unknown</c>" server.
        /// This is intended for old entries (that didn't track this) and if the server name isn't configured.
        /// </para>
        /// </remarks>
        public int ServerId { get; set; }

        public List<ServerBanHit> BanHits { get; set; } = null!;
        public Server Server { get; set; } = null!;

        public float Trust { get; set; }
    }

    public enum ConnectionDenyReason : byte
    {
        Ban = 0,
        Whitelist = 1,
        Full = 2,
        Panic = 3,
        /*
         * If baby jail is removed, please reserve this value for as long as can reasonably be done to prevent causing ambiguity in connection denial reasons.
         * Reservation by commenting out the value is likely sufficient for this purpose, but may impact projects which depend on SS14 like SS14.Admin.
         *
         * Edit: It has
         */
        BabyJail = 4,
        /// Results from rejected connections with external API checking tools
        IPChecks = 5,
        /// Results from rejected connections who are authenticated but have no modern hwid associated with them.
        NoHwid = 6
    }

    public class ServerBanHit
    {
        public int Id { get; set; }

        public int BanId { get; set; }
        public int ConnectionId { get; set; }

        public ServerBan Ban { get; set; } = null!;
        public ConnectionLog Connection { get; set; } = null!;
    }

    [Table("server_role_ban"), Index(nameof(PlayerUserId))]
    public sealed class ServerRoleBan : IBanCommon<ServerRoleUnban>
    {
        public int Id { get; set; }
        public int? RoundId { get; set; }
        public Round? Round { get; set; }
        public Guid? PlayerUserId { get; set; }
        [Required] public TimeSpan PlaytimeAtNote { get; set; }
        public NpgsqlInet? Address { get; set; }
        public TypedHwid? HWId { get; set; }

        public DateTime BanTime { get; set; }

        public DateTime? ExpirationTime { get; set; }

        public string Reason { get; set; } = null!;

        public NoteSeverity Severity { get; set; }
        [ForeignKey("CreatedBy")] public Guid? BanningAdmin { get; set; }
        public Player? CreatedBy { get; set; }

        [ForeignKey("LastEditedBy")] public Guid? LastEditedById { get; set; }
        public Player? LastEditedBy { get; set; }
        public DateTime? LastEditedAt { get; set; }

        public ServerRoleUnban? Unban { get; set; }
        public bool Hidden { get; set; }

        public string RoleId { get; set; } = null!;
    }

    [Table("server_role_unban")]
    public sealed class ServerRoleUnban : IUnbanCommon
    {
        [Column("role_unban_id")] public int Id { get; set; }

        public int BanId { get; set; }
        public ServerRoleBan Ban { get; set; } = null!;

        public Guid? UnbanningAdmin { get; set; }

        public DateTime UnbanTime { get; set; }
    }

    [Table("play_time")]
    public sealed class PlayTime
    {
        [Required, Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        [Required, ForeignKey("player")]
        public Guid PlayerId { get; set; }

        public string Tracker { get; set; } = null!;

        public TimeSpan TimeSpent { get; set; }
    }

    [Table("uploaded_resource_log")]
    public sealed class UploadedResourceLog
    {
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        public DateTime Date { get; set; }

        public Guid UserId { get; set; }

        public string Path { get; set; } = string.Empty;

        public byte[] Data { get; set; } = default!;
    }

    // Note: this interface isn't used by the game, but it *is* used by SS14.Admin.
    // Don't remove! Or face the consequences!
    public interface IAdminRemarksCommon
    {
        public int Id { get; }

        public int? RoundId { get; }
        public Round? Round { get; }

        public Guid? PlayerUserId { get; }
        public Player? Player { get; }
        public TimeSpan PlaytimeAtNote { get; }

        public string Message { get; }

        public Player? CreatedBy { get; }

        public DateTime CreatedAt { get; }

        public Player? LastEditedBy { get; }

        public DateTime? LastEditedAt { get; }
        public DateTime? ExpirationTime { get; }

        public bool Deleted { get; }
    }

    [Index(nameof(PlayerUserId))]
    public class AdminNote : IAdminRemarksCommon
    {
        [Required, Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int Id { get; set; }

        [ForeignKey("Round")] public int? RoundId { get; set; }
        public Round? Round { get; set; }

        [ForeignKey("Player")] public Guid? PlayerUserId { get; set; }
        public Player? Player { get; set; }
        [Required] public TimeSpan PlaytimeAtNote { get; set; }

        [Required, MaxLength(4096)] public string Message { get; set; } = string.Empty;
        [Required] public NoteSeverity Severity { get; set; }

        [ForeignKey("CreatedBy")] public Guid? CreatedById { get; set; }
        public Player? CreatedBy { get; set; }

        [Required] public DateTime CreatedAt { get; set; }

        [ForeignKey("LastEditedBy")] public Guid? LastEditedById { get; set; }
        public Player? LastEditedBy { get; set; }

        [Required] public DateTime? LastEditedAt { get; set; }
        public DateTime? ExpirationTime { get; set; }

        public bool Deleted { get; set; }
        [ForeignKey("DeletedBy")] public Guid? DeletedById { get; set; }
        public Player? DeletedBy { get; set; }
        public DateTime? DeletedAt { get; set; }

        public bool Secret { get; set; }
    }

    [Index(nameof(PlayerUserId))]
    public class AdminWatchlist : IAdminRemarksCommon
    {
        [Required, Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int Id { get; set; }

        [ForeignKey("Round")] public int? RoundId { get; set; }
        public Round? Round { get; set; }

        [ForeignKey("Player")] public Guid? PlayerUserId { get; set; }
        public Player? Player { get; set; }
        [Required] public TimeSpan PlaytimeAtNote { get; set; }

        [Required, MaxLength(4096)] public string Message { get; set; } = string.Empty;

        [ForeignKey("CreatedBy")] public Guid? CreatedById { get; set; }
        public Player? CreatedBy { get; set; }

        [Required] public DateTime CreatedAt { get; set; }

        [ForeignKey("LastEditedBy")] public Guid? LastEditedById { get; set; }
        public Player? LastEditedBy { get; set; }

        [Required] public DateTime? LastEditedAt { get; set; }
        public DateTime? ExpirationTime { get; set; }

        public bool Deleted { get; set; }
        [ForeignKey("DeletedBy")] public Guid? DeletedById { get; set; }
        public Player? DeletedBy { get; set; }
        public DateTime? DeletedAt { get; set; }
    }

    [Index(nameof(PlayerUserId))]
    public class AdminMessage : IAdminRemarksCommon
    {
        [Required, Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int Id { get; set; }

        [ForeignKey("Round")] public int? RoundId { get; set; }
        public Round? Round { get; set; }

        [ForeignKey("Player")]
        public Guid? PlayerUserId { get; set; }
        public Player? Player { get; set; }
        [Required] public TimeSpan PlaytimeAtNote { get; set; }

        [Required, MaxLength(4096)] public string Message { get; set; } = string.Empty;

        [ForeignKey("CreatedBy")] public Guid? CreatedById { get; set; }
        public Player? CreatedBy { get; set; }

        [Required] public DateTime CreatedAt { get; set; }

        [ForeignKey("LastEditedBy")] public Guid? LastEditedById { get; set; }
        public Player? LastEditedBy { get; set; }

        public DateTime? LastEditedAt { get; set; }
        public DateTime? ExpirationTime { get; set; }

        public bool Deleted { get; set; }
        [ForeignKey("DeletedBy")] public Guid? DeletedById { get; set; }
        public Player? DeletedBy { get; set; }
        public DateTime? DeletedAt { get; set; }

        /// <summary>
        /// Whether the message has been seen at least once by the player.
        /// </summary>
        public bool Seen { get; set; }

        /// <summary>
        /// Whether the message has been dismissed permanently by the player.
        /// </summary>
        public bool Dismissed { get; set; }
    }

    [PrimaryKey(nameof(PlayerUserId), nameof(RoleId))]
    public class RoleWhitelist
    {
        [Required, ForeignKey("Player")]
        public Guid PlayerUserId { get; set; }
        public Player Player { get; set; } = default!;

        [Required]
        public string RoleId { get; set; } = default!;
    }

    /// <summary>
    /// Defines a template that admins can use to quickly fill out ban information.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This information is not currently used by the game itself, but it is used by SS14.Admin.
    /// </para>
    /// </remarks>
    public sealed class BanTemplate
    {
        public int Id { get; set; }

        /// <summary>
        /// Title of the ban template. This is purely for reference by admins and not copied into the ban.
        /// </summary>
        public required string Title { get; set; }

        /// <summary>
        /// How long the ban should last. 0 for permanent.
        /// </summary>
        public TimeSpan Length { get; set; }

        /// <summary>
        /// The reason for the ban.
        /// </summary>
        /// <seealso cref="ServerBan.Reason"/>
        public string Reason { get; set; } = "";

        /// <summary>
        /// Exemptions granted to the ban.
        /// </summary>
        /// <seealso cref="ServerBan.ExemptFlags"/>
        public ServerBanExemptFlags ExemptFlags { get; set; }

        /// <summary>
        /// Severity of the ban
        /// </summary>
        /// <seealso cref="ServerBan.Severity"/>
        public NoteSeverity Severity { get; set; }

        /// <summary>
        /// Ban will be automatically deleted once expired.
        /// </summary>
        /// <seealso cref="ServerBan.AutoDelete"/>
        public bool AutoDelete { get; set; }

        /// <summary>
        /// Ban is not visible to players in the remarks menu.
        /// </summary>
        /// <seealso cref="ServerBan.Hidden"/>
        public bool Hidden { get; set; }
    }

    /// <summary>
    /// A hardware ID value together with its <see cref="HwidType"/>.
    /// </summary>
    /// <seealso cref="ImmutableTypedHwid"/>
    [Owned]
    public sealed class TypedHwid
    {
        public byte[] Hwid { get; set; } = default!;
        public HwidType Type { get; set; }

        [return: NotNullIfNotNull(nameof(immutable))]
        public static implicit operator TypedHwid?(ImmutableTypedHwid? immutable)
        {
            if (immutable == null)
                return null;

            return new TypedHwid
            {
                Hwid = immutable.Hwid.ToArray(),
                Type = immutable.Type,
            };
        }

        [return: NotNullIfNotNull(nameof(hwid))]
        public static implicit operator ImmutableTypedHwid?(TypedHwid? hwid)
        {
            if (hwid == null)
                return null;

            return new ImmutableTypedHwid(hwid.Hwid.ToImmutableArray(), hwid.Type);
        }
    }


    /// <summary>
    ///  Cache for the IPIntel system
    /// </summary>
    public class IPIntelCache
    {
        public int Id { get; set; }

        /// <summary>
        /// The IP address (duh). This is made unique manually for psql cause of ef core bug.
        /// </summary>
        public IPAddress Address { get; set; } = null!;

        /// <summary>
        /// Date this record was added. Used to check if our cache is out of date.
        /// </summary>
        public DateTime Time { get; set; }

        /// <summary>
        /// The score IPIntel returned
        /// </summary>
        public float Score { get; set; }
    }
}