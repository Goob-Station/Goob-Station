// SPDX-FileCopyrightText: 2023 TemporalOroboros <TemporalOroboros@gmail.com>
// SPDX-FileCopyrightText: 2023 keronshb <54602815+keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 keronshb <keronshb@live.com>
// SPDX-FileCopyrightText: 2024 Alzore <140123969+Blackern5000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Brandon Hu <103440971+Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 CaasGit <87243814+CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 EmoGarbage404 <retron404@gmail.com>
// SPDX-FileCopyrightText: 2024 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Hrosts <35345601+Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 2024 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JustCone <141039037+JustCone14@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Killerqu00 <47712032+Killerqu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ko4ergaPunk <62609550+Ko4ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kukutis96513 <146854220+Kukutis96513@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Lye <128915833+Lyroth001@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MerrytheManokit <167581110+MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MureixloI <132683811+MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 NakataRin <45946146+NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 OrangeMoronage9622 <whyteterry0092@gmail.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Preston Smith <92108534+thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Psychpsyo <60073468+Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Repo <47093363+Titian3@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 RiceMar1244 <138547931+RiceMar1244@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Simon <63975668+Simyon264@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Stalen <33173619+stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TakoDragon <69509841+BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Unkn0wn_Gh0st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 Vigers Ray <60344369+VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deathride58 <deathride58@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 dffdff2423 <dffdff2423@gmail.com>
// SPDX-FileCopyrightText: 2024 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 2024 foboscheshir <156405958+foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 nikthechampiongr <32041239+nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 saintmuntzer <47153094+saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 shamp <140359015+shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 strO0pwafel <153459934+strO0pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 2024 themias <89101928+themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 to4no_fix <156101927+chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 voidnull000 <18663194+voidnull000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <93730715+Aviu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 BombasterDS <115770678+BombasterDS@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 BombasterDS <deniskaporoshok@gmail.com>
// SPDX-FileCopyrightText: 2025 BombasterDS2 <shvalovdenis.workmail@gmail.com>
// SPDX-FileCopyrightText: 2025 Piras314 <p1r4s@proton.me>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using Content.Shared.FixedPoint;
using Robust.Shared.Serialization;

namespace Content.Shared.DoAfter;

[Serializable, NetSerializable]
[DataDefinition]
public sealed partial class DoAfterArgs
{
    /// <summary>
    ///     The entity invoking do_after
    /// </summary>
    [NonSerialized]
    [DataField("user", required: true)]
    public EntityUid User;

    public NetEntity NetUser;

    /// <summary>
    ///     How long does the do_after require to complete
    /// </summary>
    [DataField(required: true)]
    public TimeSpan Delay;

    /// <summary>
    ///     Applicable target (if relevant)
    /// </summary>
    [NonSerialized]
    [DataField]
    public EntityUid? Target;

    public NetEntity? NetTarget;

    /// <summary>
    ///     Entity used by the User on the Target.
    /// </summary>
    [NonSerialized]
    [DataField("using")]
    public EntityUid? Used;

    public NetEntity? NetUsed;

    // Goobstation - Show doAfter progress bar to another entity
    [NonSerialized]
    [DataField]
    public EntityUid? ShowTo;

    public NetEntity? NetShowTo;

    /// <summary>
    /// Whether the progress bar for this DoAfter should be hidden from other players.
    /// </summary>
    [DataField]
    public bool Hidden;

    /// <summary>
    /// Goobstation
    /// Whether the delay multiplier event should be raised
    /// </summary>
    [DataField]
    public bool MultiplyDelay = true;

    #region Event options
    /// <summary>
    ///     The event that will get raised when the DoAfter has finished. If null, this will simply raise a <see cref="SimpleDoAfterEvent"/>
    /// </summary>
    [DataField(required: true)]
    public DoAfterEvent Event = default!;

    /// <summary>
    ///     This option determines how frequently the DoAfterAttempt event will get raised. Defaults to never raising the
    ///     event.
    /// </summary>
    [DataField("attemptEventFrequency")]
    public AttemptFrequency AttemptFrequency;

    /// <summary>
    ///     Entity which will receive the directed event. If null, no directed event will be raised.
    /// </summary>
    [NonSerialized]
    [DataField]
    public EntityUid? EventTarget;

    public NetEntity? NetEventTarget;

    /// <summary>
    /// Should the DoAfter event broadcast? If this is false, then <see cref="EventTarget"/> should be a valid entity.
    /// </summary>
    [DataField]
    public bool Broadcast;
    #endregion

    #region Break/Cancellation Options
    // Break the chains
    /// <summary>
    ///     Whether or not this do after requires the user to have hands.
    /// </summary>
    [DataField]
    public bool NeedHand;

    /// <summary>
    ///     Whether we need to keep our active hand as is (i.e. can't change hand or change item). This also covers
    ///     requiring the hand to be free (if applicable). This does nothing if <see cref="NeedHand"/> is false.
    /// </summary>
    [DataField]
    public bool BreakOnHandChange = true;

    /// <summary>
    ///     Whether the do-after should get interrupted if we drop the
    ///     active item we started the do-after with
    ///     This does nothing if <see cref="NeedHand"/> is false.
    /// </summary>
    [DataField]
    public bool BreakOnDropItem = true;

    /// <summary>
    ///     If do_after stops when the user or target moves
    /// </summary>
    [DataField]
    public bool BreakOnMove;

    /// <summary>
    ///     Whether to break on movement when the user is weightless.
    ///     This does nothing if <see cref="BreakOnMove"/> is false.
    /// </summary>
    [DataField]
    public bool BreakOnWeightlessMove = true;

    /// <summary>
    ///     Threshold for user and target movement
    /// </summary>
    [DataField]
    public float MovementThreshold = 0.3f;

    /// <summary>
    ///     Threshold for distance user from the used OR target entities.
    /// </summary>
    [DataField]
    public float? DistanceThreshold;

    /// <summary>
    ///     Whether damage will cancel the DoAfter. See also <see cref="DamageThreshold"/>.
    /// </summary>
    [DataField]
    public bool BreakOnDamage;

    /// <summary>
    ///     Threshold for user damage. This damage has to be dealt in a single event, not over time.
    /// </summary>
    [DataField]
    public FixedPoint2 DamageThreshold = 1;

    /// <summary>
    ///     If true, this DoAfter will be canceled if the user can no longer interact with the target.
    /// </summary>
    [DataField]
    public bool RequireCanInteract = true;
    #endregion

    #region Duplicates
    /// <summary>
    ///     If true, this will prevent duplicate DoAfters from being started See also <see cref="DuplicateConditions"/>.
    /// </summary>
    /// <remarks>
    ///     Note that this will block even if the duplicate is cancelled because either DoAfter had
    ///     <see cref="CancelDuplicate"/> enabled.
    /// </remarks>
    [DataField]
    public bool BlockDuplicate = true;

    //TODO: User pref to not cancel on second use on specific doafters
    /// <summary>
    ///     If true, this will cancel any duplicate DoAfters when attempting to add a new DoAfter. See also
    ///     <see cref="DuplicateConditions"/>.
    /// </summary>
    [DataField]
    public bool CancelDuplicate = true;

    /// <summary>
    ///     These flags determine what DoAfter properties are used to determine whether one DoAfter is a duplicate of
    ///     another.
    /// </summary>
    /// <remarks>
    ///     Note that both DoAfters may have their own conditions, and they will be considered duplicated if either set
    ///     of conditions is satisfied.
    /// </remarks>
    [DataField]
    public DuplicateConditions DuplicateCondition = DuplicateConditions.All;
    #endregion

    /// <summary>
    ///     Additional conditions that need to be met. Return false to cancel.
    /// </summary>
    [NonSerialized]
    [Obsolete("Use checkEvent instead")]
    public Func<bool>? ExtraCheck;

    #region Constructors

    /// <summary>
    ///     Creates a new set of DoAfter arguments.
    /// </summary>
    /// <param name="user">The user that will perform the DoAfter</param>
    /// <param name="delay">The time it takes for the DoAfter to complete</param>
    /// <param name="event">The event that will be raised when the DoAfter has ended (completed or cancelled).</param>
    /// <param name="eventTarget">The entity at which the event will be directed. If null, the event will not be directed.</param>
    /// <param name="target">The entity being targeted by the DoAFter. Not the same as <see cref="EventTarget"/></param>.
    /// <param name="used">The entity being used during the DoAfter. E.g., a tool</param>
    /// <param name="showTo">Goobstation - The entity that should see doafter progress bar except doAfter entity</param>
    public DoAfterArgs(
        IEntityManager entManager,
        EntityUid user,
        TimeSpan delay,
        DoAfterEvent @event,
        EntityUid? eventTarget,
        EntityUid? target = null,
        EntityUid? used = null,
        EntityUid? showTo = null) // Goobstation - Show doAfter popup to another entity
    {
        User = user;
        Delay = delay;
        Target = target;
        Used = used;
        EventTarget = eventTarget;
        Event = @event;
        ShowTo = showTo; // Goobstation

        NetUser = entManager.GetNetEntity(User);
        NetTarget = entManager.GetNetEntity(Target);
        NetUsed = entManager.GetNetEntity(Used);
        NetShowTo = entManager.GetNetEntity(ShowTo); // Goobstation - Show doAfter popup to another entity
    }

    private DoAfterArgs()
    {
    }

    /// <summary>
    ///     Creates a new set of DoAfter arguments.
    /// </summary>
    /// <param name="user">The user that will perform the DoAfter</param>
    /// <param name="seconds">The time it takes for the DoAfter to complete, in seconds</param>
    /// <param name="event">The event that will be raised when the DoAfter has ended (completed or cancelled).</param>
    /// <param name="eventTarget">The entity at which the event will be directed. If null, the event will not be directed.</param>
    /// <param name="target">The entity being targeted by the DoAfter. Not the same as <see cref="EventTarget"/></param>.
    /// <param name="used">The entity being used during the DoAfter. E.g., a tool</param>
    public DoAfterArgs(
        IEntityManager entManager,
        EntityUid user,
        float seconds,
        DoAfterEvent @event,
        EntityUid? eventTarget,
        EntityUid? target = null,
        EntityUid? used = null)
        : this(entManager, user, TimeSpan.FromSeconds(seconds), @event, eventTarget, target, used)
    {
    }

    #endregion

    //The almighty pyramid returns.......
    public DoAfterArgs(DoAfterArgs other)
    {
        User = other.User;
        Delay = other.Delay;
        Target = other.Target;
        Used = other.Used;
        Hidden = other.Hidden;
        EventTarget = other.EventTarget;
        Broadcast = other.Broadcast;
        NeedHand = other.NeedHand;
        BreakOnHandChange = other.BreakOnHandChange;
        BreakOnDropItem = other.BreakOnDropItem;
        BreakOnMove = other.BreakOnMove;
        BreakOnWeightlessMove = other.BreakOnWeightlessMove;
        MovementThreshold = other.MovementThreshold;
        DistanceThreshold = other.DistanceThreshold;
        BreakOnDamage = other.BreakOnDamage;
        DamageThreshold = other.DamageThreshold;
        RequireCanInteract = other.RequireCanInteract;
        AttemptFrequency = other.AttemptFrequency;
        BlockDuplicate = other.BlockDuplicate;
        CancelDuplicate = other.CancelDuplicate;
        DuplicateCondition = other.DuplicateCondition;
        ShowTo = other.ShowTo; // Goobstation - Show doAfter popup to another entity

        MultiplyDelay = other.MultiplyDelay; // Goobstation

        // Networked
        NetUser = other.NetUser;
        NetTarget = other.NetTarget;
        NetUsed = other.NetUsed;
        NetEventTarget = other.NetEventTarget;
        NetShowTo = other.NetShowTo; // Goobstation - Show doAfter popup to another entity

        Event = other.Event.Clone();
    }
}

/// <summary>
///     See <see cref="DoAfterArgs.DuplicateCondition"/>.
/// </summary>
[Flags]
public enum DuplicateConditions : byte
{
    /// <summary>
    ///     This DoAfter will consider any other DoAfter with the same user to be a duplicate.
    /// </summary>
    None = 0,

    /// <summary>
    ///     Requires that <see cref="Used"/> refers to the same entity in order to be considered a duplicate.
    /// </summary>
    /// <remarks>
    ///     E.g., if all checks are enabled for stripping, then stripping different articles of clothing on the same
    ///     mob would be allowed. If instead this check were disabled, then any stripping actions on the same target
    ///     would be considered duplicates, so you would only be able to take one piece of clothing at a time.
    /// </remarks>
    SameTool = 1 << 1,

    /// <summary>
    ///     Requires that <see cref="Target"/> refers to the same entity in order to be considered a duplicate.
    /// </summary>
    /// <remarks>
    ///     E.g., if all checks are enabled for mining, then using the same pickaxe to mine different rocks will be
    ///     allowed. If instead this check were disabled, then the trying to mine a different rock with the same
    ///     pickaxe would be considered a duplicate DoAfter.
    /// </remarks>
    SameTarget = 1 << 2,

    /// <summary>
    ///     Requires that the <see cref="Event"/> types match in order to be considered a duplicate.
    /// </summary>
    /// <remarks>
    ///     If your DoAfter should block other unrelated DoAfters involving the same set of entities, you may want
    ///     to disable this condition. E.g. force feeding a donk pocket and forcefully giving someone a donk pocket
    ///     should be mutually exclusive, even though the DoAfters have unrelated effects.
    /// </remarks>
    SameEvent = 1 << 3,

    All = SameTool | SameTarget | SameEvent,
}

public enum AttemptFrequency : byte
{
    /// <summary>
    ///     Never raise the attempt event.
    /// </summary>
    Never = 0,

    /// <summary>
    ///     Raises the attempt event when the DoAfter is about to start or end.
    /// </summary>
    StartAndEnd = 1,

    /// <summary>
    ///     Raise the attempt event every tick while the DoAfter is running.
    /// </summary>
    EveryTick = 2
}