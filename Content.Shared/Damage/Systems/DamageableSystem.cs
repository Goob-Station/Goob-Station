// SPDX-FileCopyrightText: 2021 20kdc <asdd2808@gmail.com>
// SPDX-FileCopyrightText: 2021 Acruid <shatter66@gmail.com>
// SPDX-FileCopyrightText: 2021 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Javier Guardia Fern√°ndez <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <6766154+Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 2022 Alex Evgrashin <aevgrashin@yandex.ru>
// SPDX-FileCopyrightText: 2022 CommieFlowers <rasmus.cedergren@hotmail.com>
// SPDX-FileCopyrightText: 2022 EmoGarbage404 <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Flipp Syder <76629141+vulppine@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Moony <moonheart08@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Paul Ritter <ritter.paul1@googlemail.com>
// SPDX-FileCopyrightText: 2022 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 moonheart08 <moonheart08@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 rolfero <45628623+rolfero@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <drsmugleaf@gmail.com>
// SPDX-FileCopyrightText: 2023 Jezithyr <jezithyr@gmail.com>
// SPDX-FileCopyrightText: 2023 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2023 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 PixelTK <85175107+PixelTheKermit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Slava0135 <40753025+Slava0135@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2025 ActiveMammmoth <140334666+ActiveMammmoth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 ActiveMammmoth <kmcsmooth@gmail.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 Aineias1 <dmitri.s.kiselev@gmail.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <93730715+Aviu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <aviu00@protonmail.com>
// SPDX-FileCopyrightText: 2025 FaDeOkno <143940725+FaDeOkno@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Fildrance <fildrance@gmail.com>
// SPDX-FileCopyrightText: 2025 GoobBot <uristmchands@proton.me>
// SPDX-FileCopyrightText: 2025 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Kayzel <43700376+KayzelW@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 McBosserson <148172569+McBosserson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Milon <plmilonpl@gmail.com>
// SPDX-FileCopyrightText: 2025 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2025 Rouden <149893554+Roudenn@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Roudenn <romabond091@gmail.com>
// SPDX-FileCopyrightText: 2025 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Solstice <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 SolsticeOfTheWinter <solsticeofthewinter@gmail.com>
// SPDX-FileCopyrightText: 2025 Spatison <137375981+Spatison@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Ted Lukin <66275205+pheenty@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 TheBorzoiMustConsume <197824988+TheBorzoiMustConsume@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Trest <144359854+trest100@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Unlumination <144041835+Unlumy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 chromiumboy <50505512+chromiumboy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 coderabbitai[bot] <136622811+coderabbitai[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <linebarrelerenthusiast@gmail.com>
// SPDX-FileCopyrightText: 2025 gus <august.eymann@gmail.com>
// SPDX-FileCopyrightText: 2025 keronshb <54602815+keronshb@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 kurokoTurbo <92106367+kurokoTurbo@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 pheenty <fedorlukin2006@gmail.com>
// SPDX-FileCopyrightText: 2025 username <113782077+whateverusername0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 whateverusername0 <whateveremail>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Linq;
using Content.Shared.CCVar;
using Content.Shared.Chemistry;
using Content.Shared.Damage.Prototypes;
using Content.Goobstation.Maths.FixedPoint;
using Content.Shared.Inventory;
using Content.Shared.Mind.Components;
using Content.Shared.Mobs.Components;
using Content.Shared.Mobs.Systems;
using Content.Shared.Radiation.Events;
using Content.Shared.Rejuvenate;
using Robust.Shared.Configuration;
using Robust.Shared.GameStates;
using Robust.Shared.Network;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

// Shitmed Change
using Content.Shared._Shitmed.Body;
using Content.Shared._Shitmed.Body.Part;
using Content.Shared._Shitmed.Damage;
using Content.Shared._Shitmed.Medical.Surgery.Consciousness.Components;
using Content.Shared._Shitmed.Medical.Surgery.Wounds.Components;
using Content.Shared._Shitmed.Medical.Surgery.Wounds.Systems;
using Content.Shared._Shitmed.Targeting;
using Content.Shared.Body.Systems;
using Content.Shared.Body.Components;
using Content.Shared.Body.Part;
using Robust.Shared.Random;
using Robust.Shared.Timing;

namespace Content.Shared.Damage
{
    public sealed class DamageableSystem : EntitySystem
    {
        [Dependency] private readonly IPrototypeManager _prototypeManager = default!;
        [Dependency] private readonly SharedAppearanceSystem _appearance = default!;
        [Dependency] private readonly INetManager _netMan = default!;
        [Dependency] private readonly MobThresholdSystem _mobThreshold = default!;
        [Dependency] private readonly IConfigurationManager _config = default!;
        [Dependency] private readonly SharedChemistryGuideDataSystem _chemistryGuideData = default!;

        // Shitmed Dependencies
        [Dependency] private readonly SharedBodySystem _body = default!;
        [Dependency] private readonly WoundSystem _wounds = default!;
        [Dependency] private readonly IRobustRandom _LETSGOGAMBLINGEXCLAMATIONMARKEXCLAMATIONMARK = default!;
        [Dependency] private readonly IComponentFactory _factory = default!;
        [Dependency] private readonly IGameTiming _timing = default!;
        private EntityQuery<AppearanceComponent> _appearanceQuery;
        private EntityQuery<DamageableComponent> _damageableQuery;
        private EntityQuery<MindContainerComponent> _mindContainerQuery;

        // Shitmed Ent Queries
        private EntityQuery<BodyComponent> _bodyQuery;
        private EntityQuery<ConsciousnessComponent> _consciousnessQuery;
        private EntityQuery<WoundableComponent> _woundableQuery;

        public float UniversalAllDamageModifier { get; private set; } = 1f;
        public float UniversalAllHealModifier { get; private set; } = 1f;
        public float UniversalMeleeDamageModifier { get; private set; } = 1f;
        public float UniversalProjectileDamageModifier { get; private set; } = 1f;
        public float UniversalHitscanDamageModifier { get; private set; } = 1f;
        public float UniversalReagentDamageModifier { get; private set; } = 1f;
        public float UniversalReagentHealModifier { get; private set; } = 1f;
        public float UniversalExplosionDamageModifier { get; private set; } = 1f;
        public float UniversalThrownDamageModifier { get; private set; } = 1f;
        public float UniversalTopicalsHealModifier { get; private set; } = 1f;
        public float UniversalMobDamageModifier { get; private set; } = 1f;

        private ProtoId<DamageGroupPrototype>[] _vitalOnlyDamageTypes = { "Airloss", "Toxin", "Genetic", "Metaphysical" }; // Goobstation
        public override void Initialize()
        {
            SubscribeLocalEvent<DamageableComponent, ComponentInit>(DamageableInit);
            SubscribeLocalEvent<DamageableComponent, ComponentHandleState>(DamageableHandleState);
            SubscribeLocalEvent<DamageableComponent, ComponentGetState>(DamageableGetState);
            SubscribeLocalEvent<DamageableComponent, OnIrradiatedEvent>(OnIrradiated);
            SubscribeLocalEvent<DamageableComponent, RejuvenateEvent>(OnRejuvenate);

            _appearanceQuery = GetEntityQuery<AppearanceComponent>();
            _damageableQuery = GetEntityQuery<DamageableComponent>();
            _mindContainerQuery = GetEntityQuery<MindContainerComponent>();

            // Shitmed Queries
            _bodyQuery = GetEntityQuery<BodyComponent>();
            _consciousnessQuery = GetEntityQuery<ConsciousnessComponent>();
            _woundableQuery = GetEntityQuery<WoundableComponent>();

            // Damage modifier CVars are updated and stored here to be queried in other systems.
            // Note that certain modifiers requires reloading the guidebook.
            Subs.CVar(_config, CCVars.PlaytestAllDamageModifier, value =>
            {
                UniversalAllDamageModifier = value;
                _chemistryGuideData.ReloadAllReagentPrototypes();
            }, true);
            Subs.CVar(_config, CCVars.PlaytestAllHealModifier, value =>
            {
                UniversalAllHealModifier = value;
                _chemistryGuideData.ReloadAllReagentPrototypes();
            }, true);
            Subs.CVar(_config, CCVars.PlaytestProjectileDamageModifier, value => UniversalProjectileDamageModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestMeleeDamageModifier, value => UniversalMeleeDamageModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestProjectileDamageModifier, value => UniversalProjectileDamageModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestHitscanDamageModifier, value => UniversalHitscanDamageModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestReagentDamageModifier, value =>
            {
                UniversalReagentDamageModifier = value;
                _chemistryGuideData.ReloadAllReagentPrototypes();
            }, true);
            Subs.CVar(_config, CCVars.PlaytestReagentHealModifier, value =>
            {
                 UniversalReagentHealModifier = value;
                 _chemistryGuideData.ReloadAllReagentPrototypes();
            }, true);
            Subs.CVar(_config, CCVars.PlaytestExplosionDamageModifier, value => UniversalExplosionDamageModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestThrownDamageModifier, value => UniversalThrownDamageModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestTopicalsHealModifier, value => UniversalTopicalsHealModifier = value, true);
            Subs.CVar(_config, CCVars.PlaytestMobDamageModifier, value => UniversalMobDamageModifier = value, true);
        }

        /// <summary>
        ///     Initialize a damageable component
        /// </summary>
        private void DamageableInit(EntityUid uid, DamageableComponent component, ComponentInit _)
        {
            if (component.DamageContainerID != null &&
                _prototypeManager.TryIndex(component.DamageContainerID, out var damageContainerPrototype)) // Shitmed Change
            {
                // Initialize damage dictionary, using the types and groups from the damage
                // container prototype
                foreach (var type in damageContainerPrototype.SupportedTypes)
                {
                    component.Damage.DamageDict.TryAdd(type, FixedPoint2.Zero);
                }

                foreach (var groupId in damageContainerPrototype.SupportedGroups)
                {
                    var group = _prototypeManager.Index<DamageGroupPrototype>(groupId);
                    foreach (var type in group.DamageTypes)
                    {
                        component.Damage.DamageDict.TryAdd(type, FixedPoint2.Zero);
                    }
                }
            }
            else
            {
                // No DamageContainerPrototype was given. So we will allow the container to support all damage types
                foreach (var type in _prototypeManager.EnumeratePrototypes<DamageTypePrototype>())
                {
                    component.Damage.DamageDict.TryAdd(type.ID, FixedPoint2.Zero);
                }
            }

            component.Damage.GetDamagePerGroup(_prototypeManager, component.DamagePerGroup);
            component.TotalDamage = component.Damage.GetTotal();
        }

        /// <summary>
        ///     Directly sets the damage specifier of a damageable component.
        /// </summary>
        /// <remarks>
        ///     Useful for some unfriendly folk. Also ensures that cached values are updated and that a damage changed
        ///     event is raised.
        /// </remarks>
        public void SetDamage(EntityUid uid, DamageableComponent damageable, DamageSpecifier damage)
        {
            damageable.Damage = damage;
            DamageChanged(uid, damageable);
        }

        /// <summary>
        ///     If the damage in a DamageableComponent was changed, this function should be called.
        /// </summary>
        /// <remarks>
        ///     This updates cached damage information, flags the component as dirty, and raises a damage changed event.
        ///     The damage changed event is used by other systems, such as damage thresholds.
        /// </remarks>
        public void DamageChanged(EntityUid uid,
            DamageableComponent component,
            DamageSpecifier? damageDelta = null,
            bool interruptsDoAfters = true,
            EntityUid? origin = null,
            bool ignoreBlockers = false,
            DamageSpecifier? uncappedDamage = null) // Goobstation
        {
            component.Damage.GetDamagePerGroup(_prototypeManager, component.DamagePerGroup);
            component.TotalDamage = component.Damage.GetTotal();
            component.LastModifiedTime = _timing.CurTime; // Shitmed Change
            Dirty(uid, component);

            if (_appearanceQuery.TryGetComponent(uid, out var appearance) && damageDelta != null)
            {
                var data = new DamageVisualizerGroupData(component.DamagePerGroup.Keys.ToList());
                _appearance.SetData(uid, DamageVisualizerKeys.DamageUpdateGroups, data, appearance);
            }
            RaiseLocalEvent(uid, new DamageChangedEvent(component, damageDelta, interruptsDoAfters, origin, ignoreBlockers, uncappedDamage)); // Goob edit
        }

        /// <summary>
        ///     Applies damage specified via a <see cref="DamageSpecifier"/>.
        /// </summary>
        /// <remarks>
        ///     <see cref="DamageSpecifier"/> is effectively just a dictionary of damage types and damage values. This
        ///     function just applies the container's resistances (unless otherwise specified) and then changes the
        ///     stored damage data. Division of group damage into types is managed by <see cref="DamageSpecifier"/>.
        /// </remarks>
        /// <returns>
        ///     Returns a <see cref="DamageSpecifier"/> with information about the actual damage changes. This will be
        ///     null if the user had no applicable components that can take damage.
        /// </returns>
        public DamageSpecifier? TryChangeDamage(EntityUid? uid,
            DamageSpecifier damage,
            bool ignoreResistances = false,
            bool interruptsDoAfters = true,
            DamageableComponent? damageable = null,
            EntityUid? origin = null,
            bool canBeCancelled = false,
            float partMultiplier = 1.00f,
            TargetBodyPart? targetPart = null,
            bool ignoreBlockers = false,
            SplitDamageBehavior splitDamage = SplitDamageBehavior.Split,
            bool canMiss = true)
        {
            if (!uid.HasValue || !_damageableQuery.Resolve(uid.Value, ref damageable, false))
                return null;

            if (damage.Empty)
                return damage;

            // Goobstation start
            var vitalDamage = new DamageSpecifier(damage);
            vitalDamage -= vitalDamage;
            vitalDamage.TrimZeros();
            foreach (var type in _vitalOnlyDamageTypes)
            {
                vitalDamage += new DamageSpecifier(_prototypeManager.Index(type), 0f);
            }
            vitalDamage.ExclusiveAdd(damage);
            vitalDamage.TrimZeros();
            // Goobstation end

            var before = new BeforeDamageChangedEvent(damage, origin, canBeCancelled, targetPart); // Shitmed Change
            RaiseLocalEvent(uid.Value, ref before);

            if (before.Cancelled)
                return null;

            // For entities with a body, route damage through body parts and then sum it up
            if (_bodyQuery.TryGetComponent(uid.Value, out var body)
                && body.BodyType == BodyType.Complex)
            {
                damage -= vitalDamage; // Goobstation
                damage.TrimZeros(); // Goobstation

                var appliedDamage = ApplyDamageToBodyParts(uid.Value, damage, origin, ignoreResistances,
                    interruptsDoAfters, targetPart, partMultiplier, ignoreBlockers, splitDamage, canMiss);

                // Goobstation start
                var appliedVitalDamage = ApplyDamageToBodyParts(uid.Value, vitalDamage, origin, ignoreResistances,
                    interruptsDoAfters, TargetBodyPart.Vital, partMultiplier, ignoreBlockers, splitDamage, canMiss);

                var totalDamage = appliedDamage;
                if (totalDamage != null && appliedVitalDamage != null)
                    totalDamage += appliedVitalDamage;

                return totalDamage;
                // Goobstation end
            }

            // For entities without a body, apply damage directly
            return ApplyDamageToEntity(uid.Value, damage, ignoreResistances, interruptsDoAfters, origin, damageable, ignoreBlockers);
        }

        /// <summary>
        /// Applies damage to an entity with body parts, targeting specific parts as needed.
        /// </summary>
        private DamageSpecifier? ApplyDamageToBodyParts(
            EntityUid uid,
            DamageSpecifier damage,
            EntityUid? origin,
            bool ignoreResistances,
            bool interruptsDoAfters,
            TargetBodyPart? targetPart,
            float partMultiplier,
            bool ignoreBlockers = false,
            SplitDamageBehavior splitDamageBehavior = SplitDamageBehavior.Split,
            bool canMiss = true)
        {
            DamageSpecifier? totalAppliedDamage = null;
            var adjustedDamage = damage * partMultiplier;
            // This cursed shitcode lets us know if the target part is a power of 2
            // therefore having multiple parts targeted.
            if (targetPart != null
                && targetPart != 0 && (targetPart & (targetPart - 1)) != 0)
            {
                // Extract only the body parts that are targeted in the bitmask
                var targetedBodyParts = new List<(EntityUid Id,
                    BodyPartComponent Component,
                    DamageableComponent Damageable)>();

                // Get only the primitive flags (powers of 2) - these are the actual individual body parts
                var primitiveFlags = Enum.GetValues<TargetBodyPart>()
                    .Where(flag => flag != 0 && (flag & (flag - 1)) == 0) // Power of 2 check
                    .ToList();

                foreach (var flag in primitiveFlags)
                {
                    // Check if this specific flag is set in our targetPart bitmask
                    if (targetPart.Value.HasFlag(flag))
                    {
                        var query = _body.ConvertTargetBodyPart(flag);
                        var parts = _body.GetBodyChildrenOfTypeWithComponent<DamageableComponent>(uid, query.Type,
                            symmetry: query.Symmetry).ToList();

                        if (parts.Count > 0)
                            targetedBodyParts.AddRange(parts);
                    }
                }

                // If we couldn't find any of the targeted parts, fall back to all body parts
                if (targetedBodyParts.Count == 0)
                {
                    var query = _body.GetBodyChildrenWithComponent<DamageableComponent>(uid).ToList();
                    if (query.Count > 0)
                        targetedBodyParts = query;
                    else
                        return null;
                }

                // Goob edit start
                List<float>? multipliers = null;
                var damagePerPart = adjustedDamage;
                if (targetedBodyParts.Count > 0 && adjustedDamage.PartDamageVariation != 0f)
                {
                    multipliers =
                        GetDamageVariationMultipliers(adjustedDamage.PartDamageVariation, targetedBodyParts.Count);
                }
                else
                    damagePerPart = ApplySplitDamageBehaviors(splitDamageBehavior, adjustedDamage, targetedBodyParts);
                var appliedDamage = new DamageSpecifier();
                var surplusHealing = new DamageSpecifier();
                for (var i = 0; i < targetedBodyParts.Count; i++)
                {
                    var (partId, _, partDamageable) = targetedBodyParts[i];
                    var modifiedDamage = damagePerPart;
                    if (multipliers != null && multipliers.Count == targetedBodyParts.Count)
                        modifiedDamage *= multipliers[i];
                    modifiedDamage += surplusHealing;
                    // Goob edit end

                    // Apply damage to this part
                    var partDamageResult = TryChangeDamage(partId, modifiedDamage, ignoreResistances,
                        interruptsDoAfters, partDamageable, origin, ignoreBlockers: ignoreBlockers);

                    if (partDamageResult != null && !partDamageResult.Empty)
                    {
                        appliedDamage += partDamageResult;

                        /*
                            Why this ugly shitcode? Its so that we can track chems and other sorts of healing surpluses.
                            Assume you're fighting in a spaced area. Your chest has 30 damage, and every other part
                            is getting 0.5 per tick. Your chems will only be 1/11th as effective, so we take the surplus
                            healing and pass it along parts. That way a chem that would heal you for 75 brute would truly
                            heal the 75 brute per tick, and not some weird shit like 6.8 per tick.
                        */
                        foreach (var (type, damageFromDict) in modifiedDamage.DamageDict)
                        {
                            if (damageFromDict >= 0
                                || !partDamageResult.DamageDict.TryGetValue(type, out var damageFromResult)
                                || damageFromResult > 0)
                                continue;

                            // If the damage from the dict plus the surplus healing is equal to the damage from the result,
                            // we can safely set the surplus healing to 0, as that means we consumed all of it.
                            if (damageFromDict >= damageFromResult)
                            {
                                surplusHealing.DamageDict[type] = FixedPoint2.Zero;
                            }
                            else
                            {
                                if (surplusHealing.DamageDict.TryGetValue(type, out var _))
                                    surplusHealing.DamageDict[type] = damageFromDict - damageFromResult;
                                else
                                    surplusHealing.DamageDict.TryAdd(type, damageFromDict - damageFromResult);
                            }
                        }
                    }
                }

                totalAppliedDamage = appliedDamage;
            }
            else
            {
                // Target a specific body part
                TargetBodyPart? target;
                var totalDamage = damage.GetTotal();

                if (totalDamage <= 0 || !canMiss) // Whoops i think i fucked up damage here.
                    target = _body.GetTargetBodyPart(uid, origin, targetPart);
                else
                    target = _body.GetRandomBodyPart(uid, origin, targetPart);

                var (partType, symmetry) = _body.ConvertTargetBodyPart(target);
                var possibleTargets = _body.GetBodyChildrenOfType(uid, partType, symmetry: symmetry).ToList();

                if (possibleTargets.Count == 0)
                {
                    if (totalDamage <= 0)
                        return null;

                    possibleTargets = _body.GetBodyChildren(uid).ToList();
                }

                // No body parts at all?
                if (possibleTargets.Count == 0)
                    return null;

                var chosenTarget = _LETSGOGAMBLINGEXCLAMATIONMARKEXCLAMATIONMARK.PickAndTake(possibleTargets);

                if (!_damageableQuery.TryComp(chosenTarget.Id, out var partDamageable))
                    return null;

                totalAppliedDamage = TryChangeDamage(chosenTarget.Id, adjustedDamage, ignoreResistances,
                    interruptsDoAfters, partDamageable, origin, ignoreBlockers: ignoreBlockers);
            }

            return totalAppliedDamage;
        }

        /// <summary>
        /// Applies damage directly to an entity without routing through body parts.
        /// </summary>
        private DamageSpecifier? ApplyDamageToEntity(
            EntityUid uid,
            DamageSpecifier? damage,
            bool ignoreResistances,
            bool interruptsDoAfters,
            EntityUid? origin,
            DamageableComponent? damageable = null,
            bool ignoreBlockers = false)
        {
            if (!Resolve(uid, ref damageable) || damage == null)
                return null;

            // Apply resistances
            if (!ignoreResistances)
            {
                if (damageable.DamageModifierSetId != null &&
                    _prototypeManager.TryIndex(damageable.DamageModifierSetId, out var modifierSet))
                {
                    damage = DamageSpecifier.ApplyModifierSet(damage,
                        DamageSpecifier.PenetrateArmor(modifierSet, damage.ArmorPenetration)); // Goob edit
                }

                if (TryComp(uid, out BodyPartComponent? bodyPart))
                {
                    TargetBodyPart? target = _body.GetTargetBodyPart(bodyPart);
                    if (bodyPart.Body != null)
                    {
                        // First raise the event on the parent to apply any parent modifiers
                        var parentEv = new DamageModifyEvent(bodyPart.Body.Value, damage, origin, target);
                        RaiseLocalEvent(bodyPart.Body.Value, parentEv);
                        damage = parentEv.Damage;
                    }

                    // Then raise on the part itself for any part-specific modifiers
                    var ev = new DamageModifyEvent(uid, damage, origin, target);
                    RaiseLocalEvent(uid, ev);
                    damage = ev.Damage;
                }
                else
                {
                    // Not a body part, just apply modifiers normally
                    var ev = new DamageModifyEvent(uid, damage, origin);
                    RaiseLocalEvent(uid, ev);
                    damage = ev.Damage;
                }

                if (damage.Empty)
                    return damage;
            }

            damage = ApplyUniversalAllModifiers(damage);

            var delta = new DamageSpecifier(damage.ArmorPenetration,
                damage.PartDamageVariation,
                damage.WoundSeverityMultipliers); // Goob edit
            delta.DamageDict.EnsureCapacity(damage.DamageDict.Count);
            var dict = damageable.Damage.DamageDict;

            // Check for integrity cap on body parts
            bool isWoundable = false;
            FixedPoint2? damageCap = null;
            if (_woundableQuery.TryComp(uid, out var woundable))
            {
                isWoundable = true;
                damageCap = woundable.IntegrityCap;
            }

            // Apply damage
            var currentTotalDamage = damageable.TotalDamage.Float();
            FixedPoint2? remainingCap = damageCap.HasValue ? damageCap.Value - currentTotalDamage : null;

            foreach (var (type, value) in damage.DamageDict)
            {
                if (!dict.TryGetValue(type, out var oldValue))
                    continue;

                // For positive damage, we need to check if we've hit the cap
                if (value > 0)
                {
                    // Delta ignores this stuff since we need it for effects.
                    delta.DamageDict[type] = value;

                    // If we're not a woundable or we don't have a cap, apply the damage normally
                    if (!isWoundable
                        || remainingCap is null)
                    {
                        dict[type] = oldValue + value;
                        continue;
                    }

                    // If we've already hit the cap, skip this damage type
                    if (remainingCap.Value <= 0)
                        continue;

                    // Calculate how much of this damage type we can apply
                    var damageToApply = FixedPoint2.Min(value, remainingCap.Value);
                    var newValue = FixedPoint2.Max(FixedPoint2.Zero, oldValue + damageToApply);

                    // Update remaining cap
                    remainingCap -= damageToApply;

                    // Only update the dict if the value actually changed
                    if (newValue != oldValue)
                        dict[type] = newValue;
                }
                else
                {
                    // For negative damage (healing), apply normally
                    var newValue = FixedPoint2.Max(FixedPoint2.Zero, oldValue + value);
                    if (newValue != oldValue)
                    {
                        dict[type] = newValue;
                        delta.DamageDict[type] = newValue - oldValue;
                    }
                }
            }

            // Goob edit start
            DamageChanged(uid, damageable, delta, interruptsDoAfters, origin, ignoreBlockers, damage);

            // Shitmed Change: This means that the damaged part was a woundable
            // which also means we send that shit to refresh the body.
            if (delta.DamageDict.Count > 0 && isWoundable)
            {
                UpdateParentDamageFromBodyParts(uid,
                    delta,
                    interruptsDoAfters,
                    origin,
                    ignoreBlockers: ignoreBlockers);
            }
            // Goob edit end

            return delta;
        }

        /// <summary>
        /// Updates the parent entity's damage values by summing damage from all body parts.
        /// Should be called after damage is applied to any body part.
        /// </summary>
        /// <param name="bodyPartUid">The body part that received damage</param>
        /// <param name="appliedDamage">The damage that was applied to the body part</param>
        /// <param name="interruptsDoAfters">Whether this damage change interrupts do-afters</param>
        /// <param name="origin">The entity that caused the damage</param>
        /// <param name="ignoreBlockers">Whether to ignore damage blockers</param>
        /// <returns>True if parent damage was updated, false otherwise</returns>
        private bool UpdateParentDamageFromBodyParts(
            EntityUid bodyPartUid,
            DamageSpecifier? appliedDamage,
            bool interruptsDoAfters,
            EntityUid? origin,
            BodyPartComponent? bodyPart = null,
            bool ignoreBlockers = false)
        {
            // Check if this is a body part and get the parent body
            if (!Resolve(bodyPartUid, ref bodyPart, logMissing: false)
                || bodyPart.Body is not { } body
                || !TryComp(body, out DamageableComponent? parentDamageable))
                return false;

            // Reset the parent's damage values
            foreach (var type in parentDamageable.Damage.DamageDict.Keys.ToList())
                parentDamageable.Damage.DamageDict[type] = FixedPoint2.Zero;

            // Sum up damage from all body parts
            foreach (var (partId, _) in _body.GetBodyChildren(body))
            {
                if (!_damageableQuery.TryComp(partId, out var partDamageable))
                    continue;

                foreach (var (type, value) in partDamageable.Damage.DamageDict)
                {
                    if (value == 0)
                        continue;

                    if (parentDamageable.Damage.DamageDict.TryGetValue(type, out var existing))
                        parentDamageable.Damage.DamageDict[type] = existing + value;
                }
            }

            // Raise the damage changed event on the parent
            DamageChanged(body,
                parentDamageable,
                appliedDamage,
                interruptsDoAfters,
                origin,
                ignoreBlockers: ignoreBlockers);

            return true;
        }

        public List<float> GetDamageVariationMultipliers(float variation, int count)
        {
            DebugTools.AssertNotEqual(count, 0);
            var list = new List<float>(count);
            var weights = new List<float>(count);
            var totalWeight = 0f;
            var random = new System.Random((int) _timing.CurTick.Value);
            for (var i = 0; i < count; i++)
            {
                var weight = random.NextFloat() * MathF.Abs(variation) + 1f;
                weights.Add(weight);
                totalWeight += weight;
            }

            DebugTools.AssertNotEqual(totalWeight, 0f);

            foreach (var weight in weights)
            {
                list.Add(weight / totalWeight);
            }

            return list;
        }

        public DamageSpecifier ApplySplitDamageBehaviors(SplitDamageBehavior splitDamageBehavior,
            DamageSpecifier damage,
            List<(EntityUid Id, BodyPartComponent Component, DamageableComponent Damageable)> parts)
        {
            var newDamage = new DamageSpecifier(damage);
            switch (splitDamageBehavior)
            {
                case SplitDamageBehavior.None:
                    return newDamage;
                case SplitDamageBehavior.Split:
                    return newDamage / parts.Count;
                case SplitDamageBehavior.SplitEnsureAllDamaged:
                    var damagedParts = parts.Where(part =>
                        part.Damageable.TotalDamage > FixedPoint2.Zero).ToList();

                    parts.Clear();
                    parts.AddRange(damagedParts);

                    goto case SplitDamageBehavior.SplitEnsureAll;
                case SplitDamageBehavior.SplitEnsureAllOrganic:
                    var organicParts = parts.Where(part =>
                        part.Component.PartComposition == BodyPartComposition.Organic).ToList();

                    parts.Clear();
                    parts.AddRange(organicParts);

                    goto case SplitDamageBehavior.SplitEnsureAll;
                case SplitDamageBehavior.SplitEnsureAllDamagedAndOrganic:
                    var compatableParts = parts.Where(part =>
                        part.Damageable.TotalDamage > FixedPoint2.Zero &&
                        part.Component.PartComposition == BodyPartComposition.Organic).ToList();

                    parts.Clear();
                    parts.AddRange(compatableParts);
                    goto case SplitDamageBehavior.SplitEnsureAll;
                case SplitDamageBehavior.SplitEnsureAll:
                    foreach (var (type, val) in newDamage.DamageDict)
                    {
                        if (val > 0)
                        {
                            if (parts.Count > 0)
                                newDamage.DamageDict[type] = val / parts.Count;
                            else
                                newDamage.DamageDict[type] = FixedPoint2.Zero;
                        }
                        else if (val < 0)
                        {
                            var count = 0;

                            foreach (var (id, _, damageable) in parts)
                                if (damageable.Damage.DamageDict.TryGetValue(type, out var currentDamage)
                                    && currentDamage > 0)
                                    count++;

                            if (count > 0)
                                newDamage.DamageDict[type] = val / count;
                            else
                                newDamage.DamageDict[type] = FixedPoint2.Zero;
                        }
                    }
                    // We sort the parts to ensure that surplus damage gets passed from least to most damaged.
                    parts.Sort((a, b) => a.Damageable.TotalDamage.CompareTo(b.Damageable.TotalDamage));
                    return newDamage;
                default:
                    return damage;
            }
        }
        /// <summary>
        ///     Applies the two univeral "All" modifiers, if set.
        /// </summary>
        /// <param name="damage">The damage to be changed.</param>
        public DamageSpecifier ApplyUniversalAllModifiers(DamageSpecifier damage)
        {
            // Checks for changes first since they're unlikely in normal play.
            if (UniversalAllDamageModifier == 1f && UniversalAllHealModifier == 1f)
                return damage;

            foreach (var (key, value) in damage.DamageDict)
            {
                if (value == 0)
                    continue;

                if (value > 0)
                {
                    damage.DamageDict[key] *= UniversalAllDamageModifier;
                    continue;
                }

                if (value < 0)
                {
                    damage.DamageDict[key] *= UniversalAllHealModifier;
                }
            }

            return damage;
        }

        /// <summary>
        ///     Sets all damage types supported by a <see cref="DamageableComponent"/> to the specified value.
        /// </summary>
        /// <remarks>
        ///     Does nothing If the given damage value is negative.
        /// </remarks>
        public void SetAllDamage(EntityUid uid, DamageableComponent component, FixedPoint2 newValue)
        {
            // invalid value
            if (newValue < 0)
                return;

            // If entity has a body, set damage on all body parts
            if (_bodyQuery.HasComp(uid))
            {
                foreach (var (part, _) in _body.GetBodyChildren(uid))
                {
                    if (!_damageableQuery.TryComp(part, out var partDamageable))
                        continue;

                    // I LOVE RECURSION!!!
                    SetAllDamage(part, partDamageable, newValue);
                }
            }

            foreach (var type in component.Damage.DamageDict.Keys)
                component.Damage.DamageDict[type] = newValue;

            // Update cached values
            component.Damage.GetDamagePerGroup(_prototypeManager, component.DamagePerGroup);
            component.TotalDamage = component.Damage.GetTotal();

            // Setting damage does not count as 'dealing' damage
            DamageChanged(uid, component, new DamageSpecifier());

            if (_woundableQuery.TryComp(uid, out var woundable))
            {
                _wounds.UpdateWoundableIntegrity(uid, woundable);

                // Create wounds if damage was applied
                if (newValue > 0 && woundable.AllowWounds)
                {
                    foreach (var (type, value) in component.Damage.DamageDict)
                    {
                        _wounds.TryInduceWound(uid,
                            type,
                            value * component.Damage.WoundSeverityMultipliers.GetValueOrDefault(type, 1),
                            out _,
                            woundable);
                    }
                }
            }
        }

        public Dictionary<string, FixedPoint2> DamageSpecifierToWoundList(
            EntityUid uid,
            EntityUid? origin,
            TargetBodyPart targetPart,
            DamageSpecifier damageSpecifier,
            DamageableComponent damageable,
            bool ignoreResistances = false,
            float partMultiplier = 1.00f)
        {
            var damageDict = new Dictionary<string, FixedPoint2>();

            damageSpecifier = ApplyUniversalAllModifiers(damageSpecifier);

            // some wounds like Asphyxiation and Bloodloss aren't supposed to be created.
            if (!ignoreResistances)
            {
                if (damageable.DamageModifierSetId != null &&
                    _prototypeManager.TryIndex(damageable.DamageModifierSetId, out var modifierSet))
                {
                    // lol bozo
                    var spec = new DamageSpecifier
                    {
                        DamageDict = damageSpecifier.DamageDict,
                    };

                    damageSpecifier = DamageSpecifier.ApplyModifierSet(spec, modifierSet);
                }

                var ev = new DamageModifyEvent(uid, damageSpecifier, origin, targetPart);
                RaiseLocalEvent(uid, ev);
                damageSpecifier = ev.Damage;

                if (damageSpecifier.Empty)
                {
                    return damageDict;
                }
            }

            foreach (var (type, severity) in damageSpecifier.DamageDict)
            {
                if (!_prototypeManager.TryIndex<EntityPrototype>(type, out var woundPrototype)
                    || !woundPrototype.TryGetComponent<WoundComponent>(out _, _factory)
                    || severity <= 0)
                    continue;

                damageDict.Add(type, severity * partMultiplier);
            }

            return damageDict;
        }

        /// <summary>
        ///     Change the DamageContainer of a DamageableComponent. - Goobstation, Rubin Code
        /// </summary>
        public void ChangeDamageContainer(EntityUid uid, string newDamageContainerId, DamageableComponent? component = null)
        {
            if (!Resolve(uid, ref component, logMissing: false)
                || newDamageContainerId == component.DamageContainerID)
            {
                return;
            }

            // Try to get the new DamageContainerPrototype
            if (!_prototypeManager.TryIndex<DamageContainerPrototype>(newDamageContainerId, out var damageContainerPrototype))
            {
                // Return early if no DamageContainerPrototype is found
                return;
            }

            // Update the DamageContainerID
            component.DamageContainerID = new ProtoId<DamageContainerPrototype>(newDamageContainerId);

            // Clear the existing damage dictionary
            component.Damage.DamageDict.Clear();

            // Initialize damage dictionary, using the types and groups from the damage container prototype
            foreach (var type in damageContainerPrototype.SupportedTypes)
            {
                component.Damage.DamageDict.TryAdd(type, FixedPoint2.Zero);
            }

            foreach (var groupId in damageContainerPrototype.SupportedGroups)
            {
                var group = _prototypeManager.Index<DamageGroupPrototype>(groupId);
                foreach (var type in group.DamageTypes)
                {
                    component.Damage.DamageDict.TryAdd(type, FixedPoint2.Zero);
                }
            }

            component.Damage.GetDamagePerGroup(_prototypeManager, component.DamagePerGroup);
            component.TotalDamage = component.Damage.GetTotal();
        }

        public void SetDamageModifierSetId(EntityUid uid, string? damageModifierSetId, DamageableComponent? comp = null)
        {
            if (!_damageableQuery.Resolve(uid, ref comp))
                return;

            comp.DamageModifierSetId = damageModifierSetId;

            foreach (var (id, part) in _body.GetBodyChildren(uid)) // Goobstation
                EnsureComp<DamageableComponent>(id).DamageModifierSetId = damageModifierSetId;

            Dirty(uid, comp);
        }

        // Begin DeltaV Additions - We need to be able to change DamageContainer to make cultists vulnerable to Holy Damage
        public void SetDamageContainerID(Entity<DamageableComponent?> ent, string damageContainerId)
        {
            if (!_damageableQuery.Resolve(ent, ref ent.Comp))
                return;

            ent.Comp.DamageContainerID = damageContainerId;
            Dirty(ent);
        }
        // End DeltaV Additions

        private void DamageableGetState(EntityUid uid, DamageableComponent component, ref ComponentGetState args)
        {
            if (_netMan.IsServer)
            {
                args.State = new DamageableComponentState(component.Damage.DamageDict, component.DamageContainerID, component.DamageModifierSetId, component.HealthBarThreshold);
            }
            else
            {
                // avoid mispredicting damage on newly spawned entities.
                args.State = new DamageableComponentState(component.Damage.DamageDict.ShallowClone(), component.DamageContainerID, component.DamageModifierSetId, component.HealthBarThreshold);
            }
        }

        private void OnIrradiated(EntityUid uid, DamageableComponent component, OnIrradiatedEvent args)
        {
            var damageValue = FixedPoint2.New(args.TotalRads);

            // Radiation should really just be a damage group instead of a list of types.
            DamageSpecifier damage = new();
            foreach (var typeId in component.RadiationDamageTypeIDs)
            {
                damage.DamageDict.Add(typeId, damageValue);
            }

            TryChangeDamage(uid, damage, interruptsDoAfters: false, origin: args.Origin);
        }

        private void OnRejuvenate(EntityUid uid, DamageableComponent component, RejuvenateEvent args)
        {
            TryComp<MobThresholdsComponent>(uid, out var thresholds);
            _mobThreshold.SetAllowRevives(uid, true, thresholds); // do this so that the state changes when we set the damage
            SetAllDamage(uid, component, 0);
            _mobThreshold.SetAllowRevives(uid, false, thresholds);
        }

        private void DamageableHandleState(EntityUid uid, DamageableComponent component, ref ComponentHandleState args)
        {
            if (args.Current is not DamageableComponentState state)
            {
                return;
            }

            component.DamageContainerID = state.DamageContainerId;
            component.DamageModifierSetId = state.ModifierSetId;
            component.HealthBarThreshold = state.HealthBarThreshold;

            // Has the damage actually changed?
            DamageSpecifier newDamage = new() { DamageDict = new(state.DamageDict) };
            var delta = newDamage - component.Damage;
            delta.TrimZeros();

            if (delta.Empty)
                return;

            component.Damage = newDamage;
            DamageChanged(uid, component, delta);
        }
    }

    /// <summary>
    ///     Raised before damage is done, so stuff can cancel it if necessary.
    /// </summary>
    [ByRefEvent]
    public record struct BeforeDamageChangedEvent(
        DamageSpecifier Damage,
        EntityUid? Origin = null,
        bool CanBeCancelled = false, // Shitmed Change
        TargetBodyPart? TargetPart = null, // Shitmed Change
        bool Cancelled = false);

    /// <summary>
    ///     Raised on an entity when damage is about to be dealt,
    ///     in case anything else needs to modify it other than the base
    ///     damageable component.
    ///
    ///     For example, armor.
    /// </summary>
    public sealed class DamageModifyEvent : EntityEventArgs, IInventoryRelayEvent
    {
        // Whenever locational damage is a thing, this should just check only that bit of armour.
        public SlotFlags TargetSlots { get; } = ~SlotFlags.POCKET;

        public readonly EntityUid Target; // Goobstation
        public readonly DamageSpecifier OriginalDamage;
        public DamageSpecifier Damage;
        public EntityUid? Origin;
        public readonly TargetBodyPart? TargetPart; // Shitmed Change

        public DamageModifyEvent(EntityUid target, DamageSpecifier damage, EntityUid? origin = null, TargetBodyPart? targetPart = null) // Shitmed + Goobstation Change
        {
            Target = target; // Goobstation
            OriginalDamage = damage;
            Damage = damage;
            Origin = origin;
            TargetPart = targetPart; // Shitmed Change
        }
    }

    public sealed class DamageChangedEvent : EntityEventArgs
    {
        /// <summary>
        ///     This is the component whose damage was changed.
        /// </summary>
        /// <remarks>
        ///     Given that nearly every component that cares about a change in the damage, needs to know the
        ///     current damage values, directly passing this information prevents a lot of duplicate
        ///     Owner.TryGetComponent() calls.
        /// </remarks>
        public readonly DamageableComponent Damageable;

        /// <summary>
        ///     The amount by which the damage has changed. If the damage was set directly to some number, this will be
        ///     null.
        /// </summary>
        public readonly DamageSpecifier? DamageDelta;

        /// <summary>
        ///     Damage before clamp of excessive heal and damage cap was applied
        /// </summary>
        public readonly DamageSpecifier? UncappedDamage;

        /// <summary>
        ///     Was any of the damage change dealing damage, or was it all healing?
        /// </summary>
        public readonly bool DamageIncreased;

        /// <summary>
        ///     Does this event interrupt DoAfters?
        ///     Note: As provided in the constructor, this *does not* account for DamageIncreased.
        ///     As written into the event, this *does* account for DamageIncreased.
        /// </summary>
        public readonly bool InterruptsDoAfters;

        /// <summary>
        ///     Contains the entity which caused the change in damage, if any was responsible.
        /// </summary>
        public readonly EntityUid? Origin;

        /// <summary>
        ///     Whether or not the damage change should be blocked due to traumas or wounds
        /// </summary>
        public readonly bool IgnoreBlockers;

        public DamageChangedEvent(DamageableComponent damageable, DamageSpecifier? damageDelta, bool interruptsDoAfters, EntityUid? origin, bool ignoreBlockers = false, DamageSpecifier? uncapped = null) // Shitmed Change, Goob edit
        {
            Damageable = damageable;
            DamageDelta = damageDelta;
            Origin = origin;
            IgnoreBlockers = ignoreBlockers;
            if (DamageDelta == null)
                return;

            UncappedDamage = uncapped ?? damageDelta; // Goobstation

            foreach (var damageChange in DamageDelta.DamageDict.Values)
            {
                if (damageChange > 0)
                {
                    DamageIncreased = true;
                    break;
                }
            }
            InterruptsDoAfters = interruptsDoAfters && DamageIncreased;
        }
    }
}
