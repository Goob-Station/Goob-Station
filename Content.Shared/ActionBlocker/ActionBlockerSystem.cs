// SPDX-FileCopyrightText: 2021 Acruid <shatter66@gmail.com>
// SPDX-FileCopyrightText: 2021 Metal Gear Sloth <metalgearsloth@gmail.com>
// SPDX-FileCopyrightText: 2021 Paul Ritter <ritter.paul1@gmail.com>
// SPDX-FileCopyrightText: 2021 Paul Ritter <ritter.paul1@googlemail.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <6766154+Zumorica@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 Vera Aguilera Puerto <gradientvera@outlook.com>
// SPDX-FileCopyrightText: 2021 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2021 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2021 mirrorcult <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Veritius <veritiusgaming@gmail.com>
// SPDX-FileCopyrightText: 2022 ike709 <ike709@github.com>
// SPDX-FileCopyrightText: 2022 ike709 <ike709@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 metalgearsloth <metalgearsloth@gmail.com>
// SPDX-FileCopyrightText: 2023 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2023 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 keronshb <keronshb@live.com>
// SPDX-FileCopyrightText: 2024 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2024 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2024 Alice "Arimah" Heurlin <30327355+arimah@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Dakamakat <52600490+dakamakat@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 HS <81934438+HolySSSS@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JustCone <141039037+JustCone14@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PopGamer46 <yt1popgamer@gmail.com>
// SPDX-FileCopyrightText: 2024 Rouge2t7 <81053047+Sarahon@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Spessmann <156740760+Spessmann@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Tayrtahn <tayrtahn@gmail.com>
// SPDX-FileCopyrightText: 2024 Truoizys <153248924+Truoizys@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 Winkarst <74284083+Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 coolboy911 <85909253+coolboy911@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 lunarcomets <140772713+lunarcomets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 nikthechampiongr <32041239+nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 osjarw <62134478+osjarw@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 saintmuntzer <47153094+saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Арт <123451459+JustArt1m@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <93730715+Aviu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2025 ScarKy0 <106310278+ScarKy0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 themias <89101928+themias@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using Content.Shared.Body.Events;
using Content.Shared.Emoting;
using Content.Shared.Hands;
using Content.Shared.Interaction;
using Content.Shared.Interaction.Components;
using Content.Shared.Interaction.Events;
using Content.Shared.Item;
using Content.Shared.Movement.Components;
using Content.Shared.Movement.Events;
using Content.Shared.Speech;
using Content.Shared.Throwing;
using Content.Shared.Weapons.Melee;
using JetBrains.Annotations;
using Robust.Shared.Containers;

// Shitmed Change
using Content.Shared._Shitmed.Antags.Abductor;
using Content.Shared.Silicons.StationAi;
using Content.Shared.Body.Events;

namespace Content.Shared.ActionBlocker
{
    /// <summary>
    /// Utility methods to check if a specific entity is allowed to perform an action.
    /// </summary>
    [UsedImplicitly]
    public sealed class ActionBlockerSystem : EntitySystem
    {
        [Dependency] private readonly SharedContainerSystem _container = default!;

        private EntityQuery<ComplexInteractionComponent> _complexInteractionQuery;

        public override void Initialize()
        {
            base.Initialize();

            _complexInteractionQuery = GetEntityQuery<ComplexInteractionComponent>();

            SubscribeLocalEvent<InputMoverComponent, ComponentStartup>(OnMoverStartup);
        }

        private void OnMoverStartup(EntityUid uid, InputMoverComponent component, ComponentStartup args)
        {
            UpdateCanMove(uid, component);
        }

        public bool CanMove(EntityUid uid, InputMoverComponent? component = null)
        {
            return Resolve(uid, ref component, false) && component.CanMove;
        }

        public bool UpdateCanMove(EntityUid uid, InputMoverComponent? component = null)
        {
            if (!Resolve(uid, ref component, false))
                return false;

            var ev = new UpdateCanMoveEvent(uid);
            RaiseLocalEvent(uid, ev);

            if (component.CanMove == ev.Cancelled)
                Dirty(uid, component);

            component.CanMove = !ev.Cancelled;
            return !ev.Cancelled;
        }

        /// <summary>
        /// Checks if a given entity is able to do specific complex interactions.
        /// This is used to gate manipulation to general humanoids. If a mouse shouldn't be able to do something, then it's complex.
        /// </summary>
        public bool CanComplexInteract(EntityUid user)
        {
            return _complexInteractionQuery.HasComp(user);
        }

        /// <summary>
        ///     Raises an event directed at both the user and the target entity to check whether a user is capable of
        ///     interacting with this entity.
        /// </summary>
        /// <remarks>
        ///     If this is a generic interaction without a target (e.g., stop-drop-and-roll when burning), the target
        ///     may be null. Note that this is checked by <see cref="SharedInteractionSystem"/>. In the majority of
        ///     cases, systems that provide interactions will not need to check this themselves, though they may need to
        ///     check other blockers like <see cref="CanPickup(EntityUid)"/>
        /// </remarks>
        /// <returns></returns>
        public bool CanInteract(EntityUid user, EntityUid? target)
        {
            if (!CanConsciouslyPerformAction(user))
                return false;

            // Shitmed Change
            if (HasComp<StationAiOverlayComponent>(user) && HasComp<AbductorScientistComponent>(user))
                return false;

            var ev = new InteractionAttemptEvent(user, target);
            RaiseLocalEvent(user, ref ev);

            if (ev.Cancelled)
                return false;

            if (target == null || target == user)
                return true;

            var targetEv = new GettingInteractedWithAttemptEvent(user, target);
            RaiseLocalEvent(target.Value, ref targetEv);

            return !targetEv.Cancelled;
        }

        /// <summary>
        ///     Can a user utilize the entity that they are currently holding in their hands.
        /// </summary>>
        /// <remarks>
        ///     This event is automatically checked by <see cref="SharedInteractionSystem"/> for any interactions that
        ///     involve using a held entity. In the majority of cases, systems that provide interactions will not need
        ///     to check this themselves.
        /// </remarks>
        public bool CanUseHeldEntity(EntityUid user, EntityUid used)
        {
            var useEv = new UseAttemptEvent(user, used);
            RaiseLocalEvent(user, useEv);

            if (useEv.Cancelled)
                return false;

            var usedEv = new GettingUsedAttemptEvent(user);
            RaiseLocalEvent(used, usedEv);

            return !usedEv.Cancelled;
        }


        /// <summary>
        /// Whether a user conscious to perform an action.
        /// </summary>
        /// <remarks>
        /// This should be used when you want a much more permissive check than <see cref="CanInteract"/>
        /// </remarks>
        public bool CanConsciouslyPerformAction(EntityUid user)
        {
            var ev = new ConsciousAttemptEvent(user);
            RaiseLocalEvent(user, ref ev);

            return !ev.Cancelled;
        }

        public bool CanThrow(EntityUid user, EntityUid itemUid)
        {
            var ev = new ThrowAttemptEvent(user, itemUid);
            RaiseLocalEvent(user, ev);

            if (ev.Cancelled)
                return false;

            var itemEv = new ThrowItemAttemptEvent(user);
            RaiseLocalEvent(itemUid, ref itemEv);

            return !itemEv.Cancelled;
        }

        public bool CanSpeak(EntityUid uid)
        {
            // This one is used as broadcast
            var ev = new SpeakAttemptEvent(uid);
            RaiseLocalEvent(uid, ev, true);

            return !ev.Cancelled;
        }

        public bool CanDrop(EntityUid uid)
        {
            var ev = new DropAttemptEvent();
            RaiseLocalEvent(uid, ev);

            return !ev.Cancelled;
        }

        public bool CanPickup(EntityUid user, EntityUid item)
        {
            var userEv = new PickupAttemptEvent(user, item);
            RaiseLocalEvent(user, userEv);

            if (userEv.Cancelled)
                return false;

            var itemEv = new GettingPickedUpAttemptEvent(user, item);
            RaiseLocalEvent(item, itemEv);

            return !itemEv.Cancelled;
        }

        public bool CanEmote(EntityUid uid)
        {
            // This one is used as broadcast
            var ev = new EmoteAttemptEvent(uid);
            RaiseLocalEvent(uid, ev, true);

            return !ev.Cancelled;
        }

        public bool CanAttack(EntityUid uid, EntityUid? target = null, Entity<MeleeWeaponComponent>? weapon = null, bool disarm = false)
        {
            // If target is in a container can we attack
            if (target != null && _container.IsEntityInContainer(target.Value))
            {
                return false;
            }

            _container.TryGetOuterContainer(uid, Transform(uid), out var outerContainer);

            // If we're in a container can we attack the target.
            if (target != null && target != outerContainer?.Owner && _container.IsEntityInContainer(uid))
            {
                var containerEv = new CanAttackFromContainerEvent(uid, target);
                RaiseLocalEvent(uid, containerEv);
                if (!containerEv.CanAttack)
                    return false;
            }

            var ev = new AttackAttemptEvent(uid, target, weapon, disarm);
            RaiseLocalEvent(uid, ev);
            if (weapon != null) // Goobstation
                RaiseLocalEvent(weapon.Value, ev);

            if (ev.Cancelled)
                return false;

            if (target == null)
                return true;

            var tev = new GettingAttackedAttemptEvent(uid, weapon, disarm);
            RaiseLocalEvent(target.Value, ref tev);
            return !tev.Cancelled;
        }

        public bool CanChangeDirection(EntityUid uid)
        {
            var ev = new ChangeDirectionAttemptEvent(uid);
            RaiseLocalEvent(uid, ev);

            return !ev.Cancelled;
        }

        public bool CanShiver(EntityUid uid)
        {
            var ev = new ShiverAttemptEvent(uid);
            RaiseLocalEvent(uid, ref ev);

            return !ev.Cancelled;
        }

        public bool CanSweat(EntityUid uid)
        {
            var ev = new SweatAttemptEvent(uid);
            RaiseLocalEvent(uid, ref ev);

            return !ev.Cancelled;
        }

        // Shitmed Change Start - Starlight Abductors
        public bool CanInstrumentInteract(EntityUid user, EntityUid used, EntityUid? target)
        {
            var ev = new InteractionAttemptEvent(user, target);
            RaiseLocalEvent(used, ref ev);

            return !ev.Cancelled;
        }
        // Shitmed Change End - Starlight Abductors
    }
}