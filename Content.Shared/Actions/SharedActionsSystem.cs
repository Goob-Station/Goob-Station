// SPDX-FileCopyrightText: 2022 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 wrexbe <81056464+wrexbe@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 AJCM-git <60196617+AJCM-git@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 ForestNoises <33579038+ForestNoises@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2023 Menshin <Menshin@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 faint <46868845+ficcialfaint@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 0x6273 <0x40@keemail.me>
// SPDX-FileCopyrightText: 2024 12rabbits <53499656+12rabbits@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 AJCM <AJCM@tutanota.com>
// SPDX-FileCopyrightText: 2024 Aiden <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2024 Alzore <140123969+Blackern5000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 ArtisticRoomba <145879011+ArtisticRoomba@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Brandon Hu <103440971+Brandon-Huu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 CaasGit <87243814+CaasGit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Chief-Engineer <119664036+Chief-Engineer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Cojoke <83733158+Cojoke-dot@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Dimastra <65184747+Dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Dimastra <dimastra@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <10968691+DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ed <96445749+TheShuEd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Emisse <99158783+Emisse@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 EmoGarbage404 <retron404@gmail.com>
// SPDX-FileCopyrightText: 2024 Eoin Mcloughlin <helloworld@eoinrul.es>
// SPDX-FileCopyrightText: 2024 Errant <35878406+Errant-4@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Flareguy <78941145+Flareguy@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Hrosts <35345601+Hrosts@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 IProduceWidgets <107586145+IProduceWidgets@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ian <ignaz.k@live.de>
// SPDX-FileCopyrightText: 2024 Ilya246 <57039557+Ilya246@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JIPDawg <51352440+JIPDawg@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JIPDawg <JIPDawg93@gmail.com>
// SPDX-FileCopyrightText: 2024 Joel Zimmerman <JoelZimmerman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 JustCone <141039037+JustCone14@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Killerqu00 <47712032+Killerqu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kira Bridgeton <161087999+Verbalase@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ko4ergaPunk <62609550+Ko4ergaPunk@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Kukutis96513 <146854220+Kukutis96513@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Lye <128915833+Lyroth001@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MerrytheManokit <167581110+MerrytheManokit@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mervill <mervills.email@gmail.com>
// SPDX-FileCopyrightText: 2024 Moomoobeef <62638182+Moomoobeef@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Morb <14136326+Morb0@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Mr. 27 <45323883+Dutch-VanDerLinde@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 MureixloI <132683811+MureixloI@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 NakataRin <45946146+NakataRin@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Nemanja <98561806+EmoGarbage404@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 OrangeMoronage9622 <whyteterry0092@gmail.com>
// SPDX-FileCopyrightText: 2024 PJBot <pieterjan.briers+bot@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers@gmail.com>
// SPDX-FileCopyrightText: 2024 Plykiya <58439124+Plykiya@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PopGamer46 <yt1popgamer@gmail.com>
// SPDX-FileCopyrightText: 2024 Preston Smith <92108534+thetolbean@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Psychpsyo <60073468+Psychpsyo@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 PursuitInAshes <pursuitinashes@gmail.com>
// SPDX-FileCopyrightText: 2024 QueerNB <176353696+QueerNB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Repo <47093363+Titian3@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 RiceMar1244 <138547931+RiceMar1244@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 2024 ShadowCommander <10494922+ShadowCommander@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Simon <63975668+Simyon264@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 SlamBamActionman <83650252+SlamBamActionman@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Spessmann <156740760+Spessmann@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Stalen <33173619+stalengd@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TakoDragon <69509841+BackeTako@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Ubaser <134914314+UbaserB@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Unkn0wn_Gh0st <shadowstalkermll@gmail.com>
// SPDX-FileCopyrightText: 2024 Vasilis <vasilis@pikachu.systems>
// SPDX-FileCopyrightText: 2024 Vigers Ray <60344369+VigersRay@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Winkarst <74284083+Winkarst-cpu@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 beck-thompson <107373427+beck-thompson@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deathride58 <deathride58@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <39013340+deltanedas@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 deltanedas <@deltanedas:kde.org>
// SPDX-FileCopyrightText: 2024 dffdff2423 <dffdff2423@gmail.com>
// SPDX-FileCopyrightText: 2024 eoineoineoin <github@eoinrul.es>
// SPDX-FileCopyrightText: 2024 foboscheshir <156405958+foboscheshir@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 lzk <124214523+lzk228@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 metalgearsloth <comedian_vs_clown@hotmail.com>
// SPDX-FileCopyrightText: 2024 nikthechampiongr <32041239+nikthechampiongr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 plykiya <plykiya@protonmail.com>
// SPDX-FileCopyrightText: 2024 saintmuntzer <47153094+saintmuntzer@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 shamp <140359015+shampunj@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 slarticodefast <161409025+slarticodefast@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 stellar-novas <stellar_novas@riseup.net>
// SPDX-FileCopyrightText: 2024 strO0pwafel <153459934+strO0pwafel@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 stroopwafel <j.o.luijkx@student.tudelft.nl>
// SPDX-FileCopyrightText: 2024 themias <89101928+themias@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 to4no_fix <156101927+chavonadelal@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 voidnull000 <18663194+voidnull000@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 ActiveMammmoth <140334666+ActiveMammmoth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 ActiveMammmoth <kmcsmooth@gmail.com>
// SPDX-FileCopyrightText: 2025 Aiden <28298836+Aidenkrz@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Aidenkrz <aiden@djkraz.com>
// SPDX-FileCopyrightText: 2025 Aviu00 <93730715+Aviu00@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Piras314 <p1r4s@proton.me>
// SPDX-FileCopyrightText: 2025 Spatison <137375981+Spatison@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gluesniffler <159397573+gluesniffler@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 gus <august.eymann@gmail.com>
// SPDX-FileCopyrightText: 2025 keronshb <54602815+keronshb@users.noreply.github.com>
//
// SPDX-License-Identifier: AGPL-3.0-or-later

using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Content.Shared._Goobstation.Wizard;
using Content.Shared.ActionBlocker;
using Content.Shared.Actions.Components;
using Content.Shared.Actions.Events;
using Content.Shared.Administration.Logs;
using Content.Shared.Database;
using Content.Shared.Ghost;
using Content.Shared.Hands;
using Content.Shared.Heretic;
using Content.Shared.Interaction;
using Content.Shared.Inventory.Events;
using Content.Shared.Mind;
using Content.Shared.Rejuvenate;
using Content.Shared.Whitelist;
using Robust.Shared.Audio.Systems;
using Robust.Shared.GameStates;
using Robust.Shared.Map;
using Robust.Shared.Network;
using Robust.Shared.Prototypes;
using Robust.Shared.Timing;
using Robust.Shared.Utility;
namespace Content.Shared.Actions;

// Shitmed Change
using Content.Shared._Shitmed.Antags.Abductor;
using Content.Shared.Silicons.StationAi;
using Content.Shared.Popups;

public abstract class SharedActionsSystem : EntitySystem
{
    [Dependency] protected readonly IGameTiming GameTiming = default!;
    [Dependency] private readonly ISharedAdminLogManager _adminLogger = default!;
    [Dependency] private readonly ActionBlockerSystem _actionBlocker = default!;
    [Dependency] private readonly ActionContainerSystem _actionContainer = default!;
    [Dependency] private readonly EntityWhitelistSystem _whitelist = default!;
    [Dependency] private readonly RotateToFaceSystem _rotateToFace = default!;
    [Dependency] private readonly SharedAudioSystem _audio = default!;
    [Dependency] private readonly INetManager _net = default!; // Goobstation
    [Dependency] private readonly SharedPopupSystem _popup = default!; // Shitmed Change
    [Dependency] private readonly SharedInteractionSystem _interaction = default!;
    [Dependency] private readonly SharedTransformSystem _transform = default!;

    private EntityQuery<ActionComponent> _actionQuery;
    private EntityQuery<ActionsComponent> _actionsQuery;
    private EntityQuery<MindComponent> _mindQuery;

    public override void Initialize()
    {
        base.Initialize();

        _actionQuery = GetEntityQuery<ActionComponent>();
        _actionsQuery = GetEntityQuery<ActionsComponent>();
        _mindQuery = GetEntityQuery<MindComponent>();

        SubscribeLocalEvent<ActionComponent, MapInitEvent>(OnActionMapInit);

        SubscribeLocalEvent<ActionComponent, ComponentShutdown>(OnActionShutdown);

        SubscribeLocalEvent<ActionsComponent, ActionComponentChangeEvent>(OnActionCompChange);
        SubscribeLocalEvent<ActionsComponent, RelayedActionComponentChangeEvent>(OnRelayActionCompChange);
        SubscribeLocalEvent<ActionsComponent, DidEquipEvent>(OnDidEquip);
        SubscribeLocalEvent<ActionsComponent, DidEquipHandEvent>(OnHandEquipped);
        SubscribeLocalEvent<ActionsComponent, DidUnequipEvent>(OnDidUnequip);
        SubscribeLocalEvent<ActionsComponent, DidUnequipHandEvent>(OnHandUnequipped);
        SubscribeLocalEvent<ActionsComponent, RejuvenateEvent>(OnRejuventate);

        SubscribeLocalEvent<ActionsComponent, ComponentShutdown>(OnShutdown);
        SubscribeLocalEvent<ActionsComponent, ComponentGetState>(OnGetState);

        SubscribeLocalEvent<ActionComponent, ActionValidateEvent>(OnValidate);
        SubscribeLocalEvent<InstantActionComponent, ActionValidateEvent>(OnInstantValidate);
        SubscribeLocalEvent<EntityTargetActionComponent, ActionValidateEvent>(OnEntityValidate);
        SubscribeLocalEvent<WorldTargetActionComponent, ActionValidateEvent>(OnWorldValidate);

        SubscribeLocalEvent<InstantActionComponent, ActionGetEventEvent>(OnInstantGetEvent);
        SubscribeLocalEvent<EntityTargetActionComponent, ActionGetEventEvent>(OnEntityGetEvent);
        SubscribeLocalEvent<WorldTargetActionComponent, ActionGetEventEvent>(OnWorldGetEvent);

        SubscribeLocalEvent<InstantActionComponent, ActionSetEventEvent>(OnInstantSetEvent);
        SubscribeLocalEvent<EntityTargetActionComponent, ActionSetEventEvent>(OnEntitySetEvent);
        SubscribeLocalEvent<WorldTargetActionComponent, ActionSetEventEvent>(OnWorldSetEvent);

        SubscribeLocalEvent<EntityTargetActionComponent, ActionSetTargetEvent>(OnEntitySetTarget);
        SubscribeLocalEvent<WorldTargetActionComponent, ActionSetTargetEvent>(OnWorldSetTarget);

        SubscribeAllEvent<RequestPerformActionEvent>(OnActionRequest);
    }

    private void OnActionMapInit(Entity<ActionComponent> ent, ref MapInitEvent args)
    {
        var comp = ent.Comp;
        comp.OriginalIconColor = comp.IconColor;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.OriginalIconColor));
    }

    private void OnActionShutdown(Entity<ActionComponent> ent, ref ComponentShutdown args)
    {
        if (ent.Comp.AttachedEntity is {} user && !TerminatingOrDeleted(user))
            RemoveAction(user, (ent, ent));
    }

    private void OnShutdown(Entity<ActionsComponent> ent, ref ComponentShutdown args)
    {
        foreach (var actionId in ent.Comp.Actions)
        {
            RemoveAction((ent, ent), actionId);
        }
    }

    private void OnGetState(Entity<ActionsComponent> ent, ref ComponentGetState args)
    {
        args.State = new ActionsComponentState(GetNetEntitySet(ent.Comp.Actions));
    }

    /// <summary>
    /// Resolving an action's <see cref="ActionComponent"/>, only returning a value if it exists and has it.
    /// </summary>
    public Entity<ActionComponent>? GetAction(Entity<ActionComponent?>? action, bool logError = true)
    {
        if (action is not {} ent || Deleted(ent))
            return null;

        if (!_actionQuery.Resolve(ent, ref ent.Comp, logError))
            return null;

        return (ent, ent.Comp);
    }

    public void SetCooldown(Entity<ActionComponent?>? action, TimeSpan start, TimeSpan end)
    {
        if (GetAction(action) is not {} ent)
            return;

        ent.Comp.Cooldown = new ActionCooldown
        {
            Start = start,
            End = end
        };
        DirtyField(ent, ent.Comp, nameof(ActionComponent.Cooldown));
    }

    public void RemoveCooldown(Entity<ActionComponent?>? action)
    {
        if (GetAction(action) is not {} ent)
            return;

        ent.Comp.Cooldown = null;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.Cooldown));
    }

    /// <summary>
    /// Starts a cooldown starting now, lasting for <c>cooldown</c> seconds.
    /// </summary>
    public void SetCooldown(Entity<ActionComponent?>? action, TimeSpan cooldown)
    {
        var start = GameTiming.CurTime;
        SetCooldown(action, start, start + cooldown);
    }

    public void ClearCooldown(Entity<ActionComponent?>? action)
    {
        if (GetAction(action) is not {} ent)
            return;

        if (ent.Comp.Cooldown is not {} cooldown)
            return;

        ent.Comp.Cooldown = new ActionCooldown
        {
            Start = cooldown.Start,
            End = GameTiming.CurTime
        };
        DirtyField(ent, ent.Comp, nameof(ActionComponent.Cooldown));
    }

    /// <summary>
    ///     Sets the cooldown for this action only if it is bigger than the one it already has.
    /// </summary>
    public void SetIfBiggerCooldown(Entity<ActionComponent?>? action, TimeSpan cooldown)
    {
        if (GetAction(action) is not {} ent || cooldown < TimeSpan.Zero)
            return;

        var start = GameTiming.CurTime;
        var end = start + cooldown;
        if (ent.Comp.Cooldown?.End > end)
            return;

        SetCooldown((ent, ent), start, end);
    }

    /// <summary>
    /// Set an action's cooldown to its use delay, if it has one.
    /// If there is no set use delay this does nothing.
    /// </summary>
    public void StartUseDelay(Entity<ActionComponent?>? action)
    {
        if (GetAction(action) is not {} ent || ent.Comp.UseDelay is not {} delay)
            return;

        SetCooldown((ent, ent), delay);
    }

    public void SetUseDelay(Entity<ActionComponent?>? action, TimeSpan? delay)
    {
        if (GetAction(action) is not {} ent || ent.Comp.UseDelay == delay)
            return;

        ent.Comp.UseDelay = delay;
        UpdateAction(ent);
        DirtyField(ent, ent.Comp, nameof(ActionComponent.UseDelay));
    }

    public void ReduceUseDelay(Entity<ActionComponent?>? action, TimeSpan? lowerDelay)
    {
        if (GetAction(action) is not {} ent)
            return;

        if (ent.Comp.UseDelay != null && lowerDelay != null)
            ent.Comp.UseDelay -= lowerDelay;

        if (ent.Comp.UseDelay < TimeSpan.Zero)
            ent.Comp.UseDelay = null;

        UpdateAction(ent);
        DirtyField(ent, ent.Comp, nameof(ActionComponent.UseDelay));
    }

    private void OnRejuventate(Entity<ActionsComponent> ent, ref RejuvenateEvent args)
    {
        if (!args.ResetActions) // Goobstation
            return;

        foreach (var act in ent.Comp.Actions)
        {
            ClearCooldown(act);
        }
    }

    #region ComponentStateManagement
    public virtual void UpdateAction(Entity<ActionComponent> ent)
    {
        // See client-side code.
    }

    public void SetToggled(Entity<ActionComponent?>? action, bool toggled)
    {
        if (GetAction(action) is not {} ent || ent.Comp.Toggled == toggled)
            return;

        ent.Comp.Toggled = toggled;
        UpdateAction(ent);
        DirtyField(ent, ent.Comp, nameof(ActionComponent.Toggled));
    }

    public void SetEnabled(Entity<ActionComponent?>? action, bool enabled)
    {
        if (GetAction(action) is not {} ent || ent.Comp.Enabled == enabled)
            return;

        ent.Comp.Enabled = enabled;
        UpdateAction(ent);
        DirtyField(ent, ent.Comp, nameof(ActionComponent.Enabled));
    }

    #endregion

    #region Execution
    /// <summary>
    ///     When receiving a request to perform an action, this validates whether the action is allowed. If it is, it
    ///     will raise the relevant <see cref="InstantActionEvent"/>
    /// </summary>
    private void OnActionRequest(RequestPerformActionEvent ev, EntitySessionEventArgs args)
    {
        if (args.SenderSession.AttachedEntity is not { } user)
            return;

        TryPerformAction(user, ev); // Goobstation - port contents of this event to API
    }

    private void OnValidate(Entity<ActionComponent> ent, ref ActionValidateEvent args)
    {
        if ((ent.Comp.CheckConsciousness && !_actionBlocker.CanConsciouslyPerformAction(args.User))
            || (ent.Comp.CheckCanInteract && !_actionBlocker.CanInteract(args.User, null)))
            args.Invalid = true;
    }

    private void OnInstantValidate(Entity<InstantActionComponent> ent, ref ActionValidateEvent args)
    {
        _adminLogger.Add(LogType.Action,
            $"{ToPrettyString(args.User):user} is performing the {Name(ent):action} action provided by {ToPrettyString(args.Provider):provider}.");
    }

    private void OnEntityValidate(Entity<EntityTargetActionComponent> ent, ref ActionValidateEvent args)
    {
        // let WorldTargetAction handle it
        if (ent.Comp.Event is not {} ev)
        {
            DebugTools.Assert(HasComp<WorldTargetActionComponent>(ent), $"Entity-world targeting action {ToPrettyString(ent)} requires WorldTargetActionComponent");
            return;
        }

        if (args.Input.EntityTarget is not {} netTarget)
        {
            args.Invalid = true;
            return;
        }

        var user = args.User;

        var target = GetEntity(netTarget);

        var targetWorldPos = _transform.GetWorldPosition(target);

        if (ent.Comp.RotateOnUse)
            _rotateToFace.TryFaceCoordinates(user, targetWorldPos);

        if (!ValidateEntityTarget(user, target, ent))
            return;

        _adminLogger.Add(LogType.Action,
            $"{ToPrettyString(user):user} is performing the {Name(ent):action} action (provided by {ToPrettyString(args.Provider):provider}) targeted at {ToPrettyString(target):target}.");

        ev.Target = target;
    }

    private void OnWorldValidate(Entity<WorldTargetActionComponent> ent, ref ActionValidateEvent args)
    {
        var user = args.User;
        var provider = args.Provider;

        if (args.Input.EntityCoordinatesTarget is not { } netTarget)
        {
            args.Invalid |= !Fallback(); // Goob edit
            return;
        }

        var target = GetCoordinates(netTarget);

        if (ent.Comp.RotateOnUse)
            _rotateToFace.TryFaceCoordinates(user, _transform.ToMapCoordinates(target).Position);

        if (!ValidateWorldTarget(user, target, ent))
        {
            Fallback(); // Goobstation
            return;
        }

        // if the client specified an entity it needs to be valid
        var targetEntity = GetEntity(args.Input.EntityTarget);
        if (targetEntity != null && (
            !TryComp<EntityTargetActionComponent>(ent, out var entTarget) ||
            !ValidateEntityTarget(user, targetEntity.Value, (ent, entTarget))))
        {
            args.Invalid |= !Fallback(); // Goob edit
            return;
        }

        _adminLogger.Add(LogType.Action,
            $"{ToPrettyString(user):user} is performing the {Name(ent):action} action (provided by {args.Provider}) targeting {targetEntity} at {target:target}.");

        if (ent.Comp.Event is {} ev)
        {
            ev.Target = target;
            ev.Entity = targetEntity;
        }

        // Goobtation start
        return;

        bool Fallback()
        {
            if (ent.Comp.Event is not InstantWorldTargetActionEvent instantWorldEv)
                return false;

            instantWorldEv.Target = EntityCoordinates.Invalid;
            instantWorldEv.Entity = null;

            _adminLogger.Add(LogType.Action,
                $"{ToPrettyString(user):user} is performing the {Name(ent):action} action provided by {ToPrettyString(provider):provider}.");

            return true;
        }
        // Goobstation end
    }

    public bool ValidateEntityTarget(EntityUid user, EntityUid target, Entity<EntityTargetActionComponent> ent)
    {
        var (uid, comp) = ent;
        if (!target.IsValid() || Deleted(target))
            return false;

        if (_whitelist.IsWhitelistFail(comp.Whitelist, target))
            return false;

        if (_whitelist.IsBlacklistPass(comp.Blacklist, target))
            return false;

        if (_actionQuery.Comp(uid).CheckCanInteract && !_actionBlocker.CanInteract(user, target))
            return false;

        if (user == target)
            return comp.CanTargetSelf;

        var targetAction = Comp<TargetActionComponent>(uid);
        // not using the ValidateBaseTarget logic since its raycast fails if the target is e.g. a wall
        if (targetAction.CheckCanAccess)
            return _interaction.InRangeAndAccessible(user, target, range: targetAction.Range);

        // if not just checking pure range, let stored entities be targeted by actions
        // if it's out of range it probably isn't stored anyway...
        // return _interaction.CanAccessViaStorage(user, target);
        // This shit is broken - Goob edit
        return true;
    }

    public bool ValidateWorldTarget(EntityUid user, EntityCoordinates target, Entity<WorldTargetActionComponent> ent)
    {
        var targetAction = Comp<TargetActionComponent>(ent);
        return ValidateBaseTarget(user, target, (ent, targetAction));
    }

    private bool ValidateBaseTarget(EntityUid user, EntityCoordinates coords, Entity<TargetActionComponent> ent)
    {
        var comp = ent.Comp;
        if (comp.CheckCanAccess)
            return _interaction.InRangeUnobstructed(user, coords, range: comp.Range);

        // even if we don't check for obstructions, we may still need to check the range.
        var xform = Transform(user);
        if (xform.MapID != _transform.GetMapId(coords))
        {
            _popup.PopupCursor(Loc.GetString("world-target-out-of-range"), user); // Goobstation Change
            return false;
        }

        if (comp.Range <= 0)
            return true;

        var hasNoSpecificComponents = !HasComp<StationAiOverlayComponent>(user) && !HasComp<AbductorScientistComponent>(user); // Shitmed Change
        if (comp.CheckCanAccess && !_actionBlocker.CanInteract(user, null) && hasNoSpecificComponents) // Shitmed Change
            return false;

        return _transform.InRange(coords, xform.Coordinates, comp.Range);
    }

    private void OnInstantGetEvent(Entity<InstantActionComponent> ent, ref ActionGetEventEvent args)
    {
        if (ent.Comp.Event is {} ev)
            args.Event = ev;
    }

    private void OnEntityGetEvent(Entity<EntityTargetActionComponent> ent, ref ActionGetEventEvent args)
    {
        if (ent.Comp.Event is {} ev)
            args.Event = ev;
    }

    private void OnWorldGetEvent(Entity<WorldTargetActionComponent> ent, ref ActionGetEventEvent args)
    {
        if (ent.Comp.Event is {} ev)
            args.Event = ev;
    }

    private void OnInstantSetEvent(Entity<InstantActionComponent> ent, ref ActionSetEventEvent args)
    {
        if (args.Event is InstantActionEvent ev)
        {
            ent.Comp.Event = ev;
            args.Handled = true;
        }
    }

    private void OnEntitySetEvent(Entity<EntityTargetActionComponent> ent, ref ActionSetEventEvent args)
    {
        if (args.Event is EntityTargetActionEvent ev)
        {
            ent.Comp.Event = ev;
            args.Handled = true;
        }
    }

    private void OnWorldSetEvent(Entity<WorldTargetActionComponent> ent, ref ActionSetEventEvent args)
    {
        if (args.Event is WorldTargetActionEvent ev)
        {
            ent.Comp.Event = ev;
            args.Handled = true;
        }
    }

    private void OnEntitySetTarget(Entity<EntityTargetActionComponent> ent, ref ActionSetTargetEvent args)
    {
        if (ent.Comp.Event is {} ev)
        {
            ev.Target = args.Target;
            args.Handled = true;
        }
    }

    private void OnWorldSetTarget(Entity<WorldTargetActionComponent> ent, ref ActionSetTargetEvent args)
    {
        if (ent.Comp.Event is {} ev)
        {
            ev.Target = Transform(args.Target).Coordinates;
            // only set Entity if the action also has EntityTargetAction
            ev.Entity = HasComp<EntityTargetActionComponent>(ent) ? args.Target : null;
            args.Handled = true;
        }
    }

    /// <summary>
    /// Perform an action, bypassing validation checks.
    /// </summary>
    /// <param name="performer">The entity performing the action</param>
    /// <param name="action">The action being performed</param>
    /// <param name="actionEvent">An event override to perform. If null, uses <see cref="GetEvent"/></param>
    /// <param name="predicted">If false, prevents playing the action's sound on the client</param>
    public void PerformAction(Entity<ActionsComponent?> performer, Entity<ActionComponent> action, BaseActionEvent? actionEvent = null, bool predicted = true)
    {
        if (!action.Comp.Predicted) // Goobstation
            predicted = false;

        var handled = false;

        var toggledBefore = action.Comp.Toggled;

        // Note that attached entity and attached container are allowed to be null here.
        if (action.Comp.AttachedEntity != null && action.Comp.AttachedEntity != performer)
        {
            Log.Error($"{ToPrettyString(performer)} is attempting to perform an action {ToPrettyString(action)} that is attached to another entity {ToPrettyString(action.Comp.AttachedEntity)}");
            return;
        }

        actionEvent ??= GetEvent(action);

        if (actionEvent is not {} ev)
            return;

        ev.Performer = performer;

        // This here is required because of client-side prediction (RaisePredictiveEvent results in event re-use).
        ev.Handled = false;
        var target = performer.Owner;
        ev.Performer = performer;
        ev.Action = action;

        if (!action.Comp.RaiseOnUser && action.Comp.Container is {} container && !_mindQuery.HasComp(container))
            target = container;

        RaiseLocalEvent(target, (object) ev, broadcast: true);
        handled = ev.Handled;

        if (!handled)
            return; // no interaction occurred.

        // play sound, reduce charges, start cooldown
        if (ev?.Toggle == true)
            SetToggled((action, action), !action.Comp.Toggled);

        _audio.PlayPredicted(action.Comp.Sound, performer, predicted ? performer : null);

        // TODO: move to ActionCooldown ActionPerformedEvent?
        RemoveCooldown((action, action));
        StartUseDelay((action, action));

        UpdateAction(action);

        var performed = new ActionPerformedEvent(performer);
        RaiseLocalEvent(action, ref performed);
    }

    /// <summary>
    /// Goobstation
    /// Performs an action WITH all condition checks.
    /// </summary>
    public bool TryPerformAction(EntityUid user, RequestPerformActionEvent ev)
    {
        if (!_actionsQuery.TryComp(user, out var component))
            return false;

        var actionEnt = GetEntity(ev.Action);
        if (GetAction(actionEnt) is not {} action)
            return false;

        if (!CanPerformAction((user, component), action, ev))
            return false;

        // All checks passed. Perform the action!
        PerformAction((user, component), action);
        return true;
    }

    /// <summary>
    /// Goobstation
    /// Runs all checks to see if user currently can perform some action.
    /// </summary>
    public bool CanPerformAction(Entity<ActionsComponent?> user, Entity<ActionComponent> action, RequestPerformActionEvent ev)
    {
        if (!Resolve(user.Owner, ref user.Comp, false)
            || !TryComp(action, out MetaDataComponent? metaData))
            return false;

        var name = Name(action, metaData);

        // Does the user actually have the requested action?
        if (!user.Comp.Actions.Contains(action))
        {
            _adminLogger.Add(LogType.Action,
                $"{ToPrettyString(user):user} attempted to perform an action that they do not have: {name}.");
            return false;
        }

        DebugTools.Assert(action.Comp.AttachedEntity == user);
        if (!action.Comp.Enabled)
            return false;

        var curTime = GameTiming.CurTime;
        if (IsCooldownActive(action, curTime))
            return false;

        // check for action use prevention
        // TODO: make code below use this event with a dedicated component
        var attemptEv = new ActionAttemptEvent(user);
        RaiseLocalEvent(action, ref attemptEv);
        if (attemptEv.Cancelled)
            return false;

        // Validate request by checking action blockers and the like
        var provider = action.Comp.Container ?? user;
        var validateEv = new ActionValidateEvent()
        {
            Input = ev,
            User = user,
            Provider = provider
        };
        RaiseLocalEvent(action, ref validateEv);
        return !validateEv.Invalid;
    }

    #endregion

    #region AddRemoveActions

    public EntityUid? AddAction(EntityUid performer,
        [ForbidLiteral] string? actionPrototypeId,
        EntityUid container = default,
        ActionsComponent? component = null)
    {
        EntityUid? actionId = null;
        AddAction(performer, ref actionId, out _, actionPrototypeId, container, component);
        return actionId;
    }

    /// <summary>
    ///     Adds an action to an action holder. If the given entity does not exist, it will attempt to spawn one.
    ///     If the holder has no actions component, this will give them one.
    /// </summary>
    /// <param name="performer">Entity to receive the actions</param>
    /// <param name="actionId">Action entity to add</param>
    /// <param name="component">The <see cref="performer"/>'s action component of </param>
    /// <param name="actionPrototypeId">The action entity prototype id to use if <see cref="actionId"/> is invalid.</param>
    /// <param name="container">The entity that contains/enables this action (e.g., flashlight).</param>
    public bool AddAction(EntityUid performer,
        [NotNullWhen(true)] ref EntityUid? actionId,
        [ForbidLiteral] string? actionPrototypeId,
        EntityUid container = default,
        ActionsComponent? component = null)
    {
        return AddAction(performer, ref actionId, out _, actionPrototypeId, container, component);
    }

    /// <inheritdoc cref="AddAction(Robust.Shared.GameObjects.EntityUid,ref System.Nullable{Robust.Shared.GameObjects.EntityUid},string?,Robust.Shared.GameObjects.EntityUid,ActionsComponent?)"/>
    public bool AddAction(EntityUid performer,
        [NotNullWhen(true)] ref EntityUid? actionId,
        [NotNullWhen(true)] out ActionComponent? action,
        [ForbidLiteral] string? actionPrototypeId,
        EntityUid container = default,
        ActionsComponent? component = null)
    {
        if (!container.IsValid())
            container = performer;

        if (!_actionContainer.EnsureAction(container, ref actionId, out action, actionPrototypeId))
            return false;

        return AddActionDirect((performer, component), (actionId.Value, action));
    }

    /// <summary>
    ///     Adds a pre-existing action.
    /// </summary>
    public bool AddAction(Entity<ActionsComponent?> performer,
        Entity<ActionComponent?> action,
        Entity<ActionsContainerComponent?> container)
    {
        if (GetAction(action) is not {} ent)
            return false;

        if (ent.Comp.Container != container.Owner
            || !Resolve(container, ref container.Comp)
            || !container.Comp.Container.Contains(ent))
        {
            Log.Error($"Attempted to add an action with an invalid container: {ToPrettyString(ent)}");
            return false;
        }

        return AddActionDirect(performer, (ent, ent));
    }

    /// <summary>
    ///     Adds a pre-existing action. This also bypasses the requirement that the given action must be stored in a
    ///     valid action container.
    /// </summary>
    public bool AddActionDirect(Entity<ActionsComponent?> performer,
        Entity<ActionComponent?>? action)
    {
        if (GameTiming.ApplyingState) // Goobstation
            return false;

        if (GetAction(action) is not {} ent)
            return false;

        DebugTools.Assert(ent.Comp.Container == null || _net.IsClient && action?.Comp?.ClientExclusive is false || // Goob edit
                          (TryComp(ent.Comp.Container, out ActionsContainerComponent? containerComp)
                           && containerComp.Container.Contains(ent)));

        if (ent.Comp.AttachedEntity is {} user)
            RemoveAction(user, (ent, ent));

        // TODO: make this an event bruh
        if (ent.Comp.StartDelay && ent.Comp.UseDelay != null)
            SetCooldown((ent, ent), ent.Comp.UseDelay.Value);

        DebugTools.AssertOwner(performer, performer.Comp);
        performer.Comp ??= EnsureComp<ActionsComponent>(performer);
        ent.Comp.AttachedEntity = performer;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.AttachedEntity));
        performer.Comp.Actions.Add(ent);
        Dirty(performer, performer.Comp);
        ActionAdded((performer, performer.Comp), (ent, ent.Comp));
        return true;
    }

    /// <summary>
    /// This method gets called after a new action got added.
    /// </summary>
    protected virtual void ActionAdded(Entity<ActionsComponent> performer, Entity<ActionComponent> action)
    {
        // See client-side system for UI code.
    }

    /// <summary>
    ///     Grant pre-existing actions. If the entity has no action component, this will give them one.
    /// </summary>
    /// <param name="performer">Entity to receive the actions</param>
    /// <param name="actions">The actions to add</param>
    /// <param name="container">The entity that enables these actions (e.g., flashlight). May be null (innate actions).</param>
    public void GrantActions(Entity<ActionsComponent?> performer,
        IEnumerable<EntityUid> actions,
        Entity<ActionsContainerComponent?> container)
    {
        if (!Resolve(container, ref container.Comp))
            return;

        DebugTools.AssertOwner(performer, performer.Comp);
        performer.Comp ??= EnsureComp<ActionsComponent>(performer);

        foreach (var actionId in actions)
        {
            AddAction(performer, actionId, container);
        }
    }

    /// <summary>
    ///     Grants all actions currently contained in some action-container. If the target entity has no action
    /// component, this will give them one.
    /// </summary>
    /// <param name="performer">Entity to receive the actions</param>
    /// <param name="container">The entity that contains thee actions.</param>
    public void GrantContainedActions(Entity<ActionsComponent?> performer, Entity<ActionsContainerComponent?> container)
    {
        if (!Resolve(container, ref container.Comp))
            return;

        performer.Comp ??= EnsureComp<ActionsComponent>(performer);

        var ghost = HasComp<GhostComponent>(performer); // Goobstation

        foreach (var actionId in container.Comp.Container.ContainedEntities)
        {
            if (GetAction(actionId) is {} action && (!ghost || action.Comp.AllowGhostAction))
                AddActionDirect(performer, (action, action));
        }
    }

    /// <summary>
    ///     Grants the provided action from the container to the target entity. If the target entity has no action
    /// component, this will give them one.
    /// </summary>
    /// <param name="performer"></param>
    /// <param name="container"></param>
    /// <param name="actionId"></param>
    public void GrantContainedAction(Entity<ActionsComponent?> performer, Entity<ActionsContainerComponent?> container, EntityUid actionId)
    {
        if (!Resolve(container, ref container.Comp))
            return;

        performer.Comp ??= EnsureComp<ActionsComponent>(performer);

        AddActionDirect(performer, actionId);
    }

    public IEnumerable<Entity<ActionComponent>> GetActions(EntityUid holderId, ActionsComponent? actions = null)
    {
        if (!Resolve(holderId, ref actions, false))
            yield break;

        foreach (var actionId in actions.Actions)
        {
            if (GetAction(actionId) is not {} ent)
                continue;

            yield return ent;
        }
    }

    /// <summary>
    ///     Remove any actions that were enabled by some other entity. Useful when unequiping items that grant actions.
    /// </summary>
    public void RemoveProvidedActions(EntityUid performer, EntityUid container, ActionsComponent? comp = null)
    {
        if (!Resolve(performer, ref comp, false))
            return;

        foreach (var actionId in comp.Actions.ToArray())
        {
            if (GetAction(actionId) is not {} ent)
                return;

            if (ent.Comp.Container == container)
                RemoveAction((performer, comp), (ent, ent));
        }
    }

    /// <summary>
    ///     Removes a single provided action provided by another entity.
    /// </summary>
    public void RemoveProvidedAction(EntityUid performer, EntityUid container, EntityUid actionId, ActionsComponent? comp = null)
    {
        if (!_actionsQuery.Resolve(performer, ref comp, false) || GetAction(actionId) is not {} ent)
            return;

        if (ent.Comp.Container == container)
            RemoveAction((performer, comp), (ent, ent));
    }

    /// <summary>
    /// Removes an action from its container, if it still exists.
    /// </summary>
    public void RemoveAction(Entity<ActionComponent?>? action)
    {
        if (GetAction(action) is not {} ent || ent.Comp.AttachedEntity is not {} actions)
            return;

        if (!_actionsQuery.TryComp(actions, out var comp))
            return;

        RemoveAction((actions, comp), (ent, ent));
    }

    public void RemoveAction(Entity<ActionsComponent?> performer, Entity<ActionComponent?>? action)
    {
        if (GetAction(action) is not {} ent)
            return;

        if (ent.Comp.AttachedEntity != performer.Owner)
        {
            DebugTools.Assert(!Resolve(performer, ref performer.Comp, false)
                              || performer.Comp.LifeStage >= ComponentLifeStage.Stopping
                              || !performer.Comp.Actions.Contains(ent.Owner));

            if (!GameTiming.ApplyingState)
                Log.Error($"Attempted to remove an action {ToPrettyString(ent)} from an entity that it was never attached to: {ToPrettyString(performer)}. Trace: {Environment.StackTrace}");
            return;
        }

        if (!_actionsQuery.Resolve(performer, ref performer.Comp, false))
        {
            DebugTools.Assert(performer == null || TerminatingOrDeleted(performer));
            ent.Comp.AttachedEntity = null;
            // TODO: should this delete the action since it's now orphaned?
            return;
        }

        performer.Comp.Actions.Remove(ent.Owner);
        Dirty(performer, performer.Comp);
        ent.Comp.AttachedEntity = null;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.AttachedEntity));
        ActionRemoved((performer, performer.Comp), ent);

        if (ent.Comp.Temporary)
            QueueDel(ent);
    }

    /// <summary>
    /// This method gets called after an action got removed.
    /// </summary>
    protected virtual void ActionRemoved(Entity<ActionsComponent> performer, Entity<ActionComponent> action)
    {
        // See client-side system for UI code.
    }

    // Goobstation start
    protected virtual void SaveActions(EntityUid performer)
    {
    }

    protected virtual void LoadActions(EntityUid performer)
    {
    }
    // Goobstation end

    public bool ValidAction(Entity<ActionComponent> ent, bool canReach = true)
    {
        var (uid, comp) = ent;
        if (!comp.Enabled)
            return false;

        var curTime = GameTiming.CurTime;
        if (comp.Cooldown.HasValue && comp.Cooldown.Value.End > curTime)
            return false;

        // TODO: use event for this
        return canReach || Comp<TargetActionComponent>(ent)?.CheckCanAccess == false;
    }

    #endregion

    private void OnRelayActionCompChange(Entity<ActionsComponent> ent, ref RelayedActionComponentChangeEvent args)
    {
        if (args.Handled)
            return;

        var ev = new AttemptRelayActionComponentChangeEvent();
        RaiseLocalEvent(ent.Owner, ref ev);
        var target = ev.Target ?? ent.Owner;

        args.Handled = true;
        args.Toggle = true;

        if (!args.Action.Comp.Toggled)
        {
            EntityManager.AddComponents(target, args.Components);
        }
        else
        {
            EntityManager.RemoveComponents(target, args.Components);
        }
    }

    private void OnActionCompChange(Entity<ActionsComponent> ent, ref ActionComponentChangeEvent args)
    {
        if (args.Handled)
            return;

        args.Handled = true;
        args.Toggle = true;
        var target = ent.Owner;

        if (!args.Action.Comp.Toggled)
        {
            EntityManager.AddComponents(target, args.Components);
        }
        else
        {
            EntityManager.RemoveComponents(target, args.Components);
        }
    }

    #region EquipHandlers
    private void OnDidEquip(Entity<ActionsComponent> ent, ref DidEquipEvent args)
    {
        if (GameTiming.ApplyingState || !GameTiming.IsFirstTimePredicted) // Goob edit
            return;

        var ev = new GetItemActionsEvent(_actionContainer, args.Equipee, args.Equipment, args.SlotFlags);
        RaiseLocalEvent(args.Equipment, ev);

        if (ev.Actions.Count == 0)
            return;

        GrantActions((ent, ent), ev.Actions, args.Equipment);

        LoadActions(args.Equipee); // Goobstation
    }

    private void OnHandEquipped(Entity<ActionsComponent> ent, ref DidEquipHandEvent args)
    {
        if (GameTiming.ApplyingState || !GameTiming.IsFirstTimePredicted) // Goob edit
            return;

        var ev = new GetItemActionsEvent(_actionContainer, args.User, args.Equipped);
        RaiseLocalEvent(args.Equipped, ev);

        if (ev.Actions.Count == 0)
            return;

        GrantActions((ent, ent), ev.Actions, args.Equipped);

        LoadActions(args.User); // Goobstation
    }

    private void OnDidUnequip(EntityUid uid, ActionsComponent component, DidUnequipEvent args)
    {
        if (GameTiming.ApplyingState || !GameTiming.IsFirstTimePredicted) // Goob edit
            return;

        // Goobstation start
        if (!TerminatingOrDeleted(args.Equipment))
        {
            var ev = new GetItemActionsEvent(_actionContainer, args.Equipee, args.Equipment);
            RaiseLocalEvent(args.Equipment, ev);

            if (ev.Actions.Count > 0)
                SaveActions(uid);
        }
        // Goobstation end

        RemoveProvidedActions(uid, args.Equipment, component);
    }

    private void OnHandUnequipped(EntityUid uid, ActionsComponent component, DidUnequipHandEvent args)
    {
        if (GameTiming.ApplyingState || !GameTiming.IsFirstTimePredicted) // Goob edit
            return;

        // Goobstation start
        if (!TerminatingOrDeleted(args.Unequipped))
        {
            var ev = new GetItemActionsEvent(_actionContainer, args.User, args.Unequipped);
            RaiseLocalEvent(args.Unequipped, ev);

            if (ev.Actions.Count > 0)
                SaveActions(uid);
        }
        // Goobstation end

        RemoveProvidedActions(uid, args.Unequipped, component);
    }
    #endregion

    public void SetEntityIcon(Entity<ActionComponent?> ent, EntityUid? icon)
    {
        if (!_actionQuery.Resolve(ent, ref ent.Comp) || ent.Comp.EntityIcon == icon)
            return;

        ent.Comp.EntityIcon = icon;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.EntIcon));
    }

    public void SetIcon(Entity<ActionComponent?> ent, SpriteSpecifier? icon)
    {
        if (!_actionQuery.Resolve(ent, ref ent.Comp) || ent.Comp.Icon == icon)
            return;

        ent.Comp.Icon = icon;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.Icon));
    }

    public void SetIconOn(Entity<ActionComponent?> ent, SpriteSpecifier? iconOn)
    {
        if (!_actionQuery.Resolve(ent, ref ent.Comp) || ent.Comp.IconOn == iconOn)
            return;

        ent.Comp.IconOn = iconOn;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.IconOn));
    }

    public void SetIconColor(Entity<ActionComponent?> ent, Color color)
    {
        if (!_actionQuery.Resolve(ent, ref ent.Comp) || ent.Comp.IconColor == color)
            return;

        ent.Comp.IconColor = color;
        DirtyField(ent, ent.Comp, nameof(ActionComponent.IconColor));
    }

    /// <summary>
    /// Set the event of an action.
    /// Since the event isn't required to be serializable this is not networked.
    /// Only use this if it's predicted or for a clientside action.
    /// </summary>
    public void SetEvent(EntityUid uid, BaseActionEvent ev)
    {
        // now this is meta
        var setEv = new ActionSetEventEvent(ev);
        RaiseLocalEvent(uid, ref setEv);
        if (!setEv.Handled)
            Log.Error($"Tried to set event of {ToPrettyString(uid):action} but nothing handled it!");
    }

    public BaseActionEvent? GetEvent(EntityUid uid)
    {
        DebugTools.Assert(_actionQuery.HasComp(uid), $"Entity {ToPrettyString(uid)} is missing ActionComponent");
        var ev = new ActionGetEventEvent();
        RaiseLocalEvent(uid, ref ev);
        return ev.Event;
    }

    public bool SetEventTarget(EntityUid uid, EntityUid target)
    {
        DebugTools.Assert(_actionQuery.HasComp(uid), $"Entity {ToPrettyString(uid)} is missing ActionComponent");
        var ev = new ActionSetTargetEvent(target);
        RaiseLocalEvent(uid, ref ev);
        return ev.Handled;
    }

    /// <summary>
    ///     Checks if the action has a cooldown and if it's still active
    /// </summary>
    public bool IsCooldownActive(ActionComponent action, TimeSpan? curTime = null)
    {
        // TODO: Check for charge recovery timer
        return action.Cooldown.HasValue && action.Cooldown.Value.End > curTime;
    }

    /// <summary>
    /// Marks the action as temporary.
    /// Temporary actions get deleted upon being removed from an entity.
    /// </summary>
    public void SetTemporary(Entity<ActionComponent?> ent, bool temporary)
    {
        if (!Resolve(ent.Owner, ref ent.Comp, false))
            return;

        ent.Comp.Temporary = temporary;
        Dirty(ent);
    }

    // Shitmed Change Start - Starlight Abductors
    public EntityUid[] HideActions(EntityUid performer, ActionsComponent? comp = null)
    {
        if (!Resolve(performer, ref comp, false))
            return [];

        var actions = comp.Actions.ToArray();
        comp.Actions.Clear();
        Dirty(performer, comp);
        return actions;
    }

    public void UnHideActions(EntityUid performer, EntityUid[] actions, ActionsComponent? comp = null)
    {
        if (!Resolve(performer, ref comp, false))
            return;

        foreach (var action in actions)
            comp.Actions.Add(action);
        Dirty(performer, comp);
    }
    // Shitmed Change End

    // Goobstation edit start
    public bool TryGetActionById(
        EntityUid actionContainer,
        EntProtoId actionId,
        [NotNullWhen(true)] out Entity<ActionComponent>? action)
    {
        action = null;
        var actions = GetActions(actionContainer).ToList();
        foreach (var (uid, comp) in actions)
        {
            if (TerminatingOrDeleted(uid))
                continue;

            var entityPrototypeId = MetaData(uid).EntityPrototype?.ID;
            if (entityPrototypeId == null
                || entityPrototypeId != actionId)
                continue;

            action = (uid, comp);
            return true;
        }

        return false;
    }
    // Goobstation edit end
}
